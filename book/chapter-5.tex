\chapter{حساب}

\section{اعمال ریاضی در پرولوگ}

پرولوگ ابزارهای ساده‌ای برای انجام محاسبات ریاضی روی اعداد صحیح \متن‌لاتین{(...,-2,-1,0,1,2,...)} دارد. البته اکثر پیاده‌سازی‌های جدید پرولوگ قابلیت کار با اعداد اعشاری را نیز دارند که ما در اینجا به آنها نمی‌پردازیم زیرا در محاسبات منطقی کاربردی ندارند. کار را با چهار عمل اصلی ریاضی در پرولوگ شروع می‌کنیم. به مثال‌های زیر توجه کنید:

\begin{latin}
\begin{lstlisting}
?- 8 is 6+2.
yes

?- 12 is 6*2.
yes

?- -2 is 6-8.
yes

?- 3 is 7/2.
yes

?- 1 is mod(7,2).
yes
\end{lstlisting}
\end{latin}

توجه داشته باشید که نتیجه تقسیم ۷ بر ۲ برابر ۳ است به این دلیل که ما با اعداد صحیح کار می‌کنیم و پرولوگ باقی مانده تقسیم را در نظر نمی‌گیرد.

مهم‌تر از مثال‌های بالا، استفاده از متغیر برای یافتن پاسخ یک عمل ریاضی است:

\begin{latin}
\begin{lstlisting}
?- X is 6+2.
X = 8

?- X is 6*2.
X = 12

?- R is mod(7,2).
R = 1
\end{lstlisting}
\end{latin}

علاوه بر این، می‌توانید از اعمال ریاضی در تعریف محمول‌ها هم استفاده کنید. فرض کنید می‌خواهیم محمول \متن‌لاتین{add\_3\_and\_double/2} را تعریف کنیم که دو آرگومان دریافت می‌کند. به آرگومان اول ۳ تا اضافه می‌کند و نتیجه را دو برابر کرده و در آرگومان دوم می‌ریزد.

\begin{latin}
\begin{lstlisting}
add_3_and_double(X,Y) :- Y is (X+3)*2.
\end{lstlisting}
\end{latin}

و این تعریف به خوبی کار می‌کند:

\begin{latin}
\begin{lstlisting}
?- add_3_and_double(1,X).
X = 8

?- add_3_and_double(2,X).
X = 10
\end{lstlisting}
\end{latin}

نکته‌ای که باید به آن توجه داشته باشید این است که پرولوگ قراردادهای معمول محاسبات ریاضی را رعایت می‌کند. مثلاً هنگامی که می‌نویسیم \متن‌لاتین{3+2*4} منظور \متن‌لاتین{3+(2*4)} است نه \متن‌لاتین{(3+2)*4}.

\section{نگاه دقیقتر}
اولین نکته‌ای که باید بدانیم این است که \متن‌لاتین{+}،\متن‌لاتین{-}،\متن‌لاتین{*}،\متن‌لاتین{÷} و \متن‌لاتین{mod} محاسبات ریاضی انجام نمی‌دهند. عباراتی نظیر \متن‌لاتین{2+3} و \متن‌لاتین{2*3} تنها چند term هستند. \متن‌لاتین{+} و \متن‌لاتین{*} \متن‌لاتین{functor‌}های این ترم‌ها و \متن‌لاتین{3} و \متن‌لاتین{2} آرگومان هستند. به غیر از اینکه این functor ها بین دو آرگومان قرار گرفته‌اند و نه در ابتدای آن‌ها، هیچ چیز عجیب دیگری در اینجا وجود ندارد و پرولوگ شبیه تمام ترم‌های دیگر با آن‌ها برخورد می‌کند. با این توصیف فکر می‌کنید پاسخ پرولوگ به پرسش زیر چیست؟

\begin{latin}
\begin{lstlisting}
?- X = 3+2
\end{lstlisting}
\end{latin}

با توضیحاتی که در بالا داده شد مشخص است که پاسخ \متن‌لاتین{X=5} را نخواهیم دید! بلکه پاسخ به شکل زیر خواهد بود.

\begin{latin}
\begin{lstlisting}
X = 3+2
yes
\end{lstlisting}
\end{latin}

پرولوگ تنها متغیر X را با ترم \متن‌لاتین{3+2} متحد کرد. برای اینکه پرولوگ را مجبور به انجام محاسبات ریاضی کنیم باید از \متن‌لاتین{is} استفاده کنیم؛ مانند مثال‌هایی که در اول این فصل دیدیم. در حقیقت \متن‌لاتین{is} یک کار خاص انجام می‌دهد و آن این است که به پرولوگ می‌گوید «با این ترم مثل ترم‌های دیگر برخورد نکن بلکه از قابلیت‌های ریاضی‌ات برای انجام محاسبه استفاده کن!»

به طور خلاصه، \متن‌لاتین{is} پرولوگ را مجبور به انجام کار غیر عادی می‌کند. در حالت عادی پرولوگ وظیفه خود یعنی اتحاد بین متغیرها و ساختارها را به خوبی انجام می‌دهد. و این چیزی است که پرولوگ برای آن ساخته شده‌است. ولی عملیات ریاضی چیزی است که بعدها بر حسب ضرورت به پرولوگ اضافه شده‌است. بنابراین محدودیت‌هایی در عملیات ریاضی وجود دارد که در ادامه به آنها می‌پردازیم.

به عنوان اولین محدودیت، باید بدانیم که عبارات محاسباتی باید در سمت راست \متن‌لاتین{is} قرار بگیرند. در مثال بالا اگر عبارت \متن‌لاتین{3+2} را در سمت چپ is قرار دهیم با خطا مواجه خواهیم شد:

\begin{latin}
\begin{lstlisting}
?- 3+2 is X.
ERROR: is/2: Arguments are not sufficiently instantiated
\end{lstlisting}
\end{latin}

دومین محدودیتی که باید به آن اشاره کنیم این است که اگرچه می‌توانیم از متغیر در سمت راست \متن‌لاتین{is} استفاده کنیم، ولی باید توجه داشته باشیم که این متغیر حتماً باید با یک عدد صحیح مقداردهی شده باشد. اگر متغیر مقداردهی نشده باشد و یا مقداری غیر از یک عدد صحیح داشته باشد با خطایی شبیه بالا روبرو می‌شویم. البته این رفتار پرولوگ کاملاً قابل درک است. محاسبه ریاضی کاری نیست که توسط مکانیزم همیشگی پرولوگ یعنی اتحاد و جستجو انجام شود بلکه انجام آن نیاز به فراخوانی یک جعبه سیاه در پرولوگ دارد. این جعبه سیاه تنها اعداد صحیح را می‌شناسد و چیزی از پایگاه داده نمی‌داند. بنابراین طبیعی است که در برخورد با هرچیزی غیر از عدد سردرگم شود.

به مثالی که در اول فصل زدیم برگردیم.

\begin{latin}
\begin{lstlisting}
add_3_and_double(X,Y) :- Y is (X+3)*2.
\end{lstlisting}
\end{latin}

وقتی در مورد این محمول توضیح دادیم گفتیم که در اینجا، عدد سه را به آرگومان اول اضافه می‌کنیم و نتیجه را دو برابر کرده و در متغیر دوم می‌ریزیم. به عنوان مثال \متن‌لاتین{add\_3\_and\_double(3,X)} پاسخ \متن‌لاتین{X = 12} را برمی‌گرداند. نکته اینجاست که هیچ چیزی در مورد قرار دادن یک متغیر در آرگومان اول نگفتیم. طبق روال معمول انتظار داریم که \متن‌لاتین{add\_3\_and\_double(X,12)} پاسخ \متن‌لاتین{X = 3} را باز گرداند. ولی این اتفاق نمی‌افتد و با خطا مواجه می‌شویم! اگر کمی دقت کنیم می‌بینیم که در اینجا از پرولوگ خواسته‌ایم عبارت \متن‌لاتین{12 is (X+3)*2} را محاسبه کند و وجود متغیر بدون مقدار X کار را غیر ممکن می‌کند.

و نکته آخر. همانطور که دیدیم برای پرولوگ \متن‌لاتین{3+2} تنها یک ترم است. اما حقیقت این است که پرولوگ این ترم را به صورت \متن‌لاتین{+(3,2)} می‌بیند. \متن‌لاتین{3+2} نحوه نگارشی است که برای ما چشم‌نوازتر است ولی در واقع می‌توانیم به صورت زیر عمل کنیم

\begin{latin}
\begin{lstlisting}
?- X is +(3,2)
X = 5
\end{lstlisting}
\end{latin}

حتی می‌توانیم بگوییم

\begin{latin}
\begin{lstlisting}
?- is(X,+(3,2))
X = 5
\end{lstlisting}
\end{latin}

به این دلیل که برای پرولوگ \متن‌لاتین{X is +(3,2)} همان ترم \متن‌لاتین{is(X,+(3,2))} است.

به طور خلاصه، انجام محاسبات ریاضی در پرولوگ آسان است فقط باید به یاد داشته باشید که توسط \متن‌لاتین{is} پرولوگ را به اینکار مجبور کنید، عبارات محاسباتی را در سمت راست قرار دهید و متغیرهای سمت راست را قبلاً مقداردهی کنید.

\section{لیست‌ها و محاسبات}
مهمترین کاربرد محاسبات در این درس، استفاده از آن برای کار با ساختارهایی مثل لیست است. در این قسمت می‌خواهیم چند مثال از این کاربردها را ببینیم.

طول یک لیست چقدر است؟ تعریف بازگشتی زیر را در نظر بگیرید:

\begin{enumerate}
\فقره طول لیست خالی صفر است.
\فقره طول یک لیست برابر است با \متن‌لاتین{1 + len(T)} که \متن‌لاتین{len(T)} طول tail لیست است.
\end{enumerate}

این تعریف دقیقاً یک برنامه است که به زبان پرولوگ به شکل زیر درمی‌آید.

\begin{latin}
\begin{lstlisting}
len([],0).
len([_|T],N) :- len(T,X), N is X+1.
\end{lstlisting}
\end{latin}

این محمول آنطور که انتظار می‌رود کار می‌کند. برای مثال

\begin{latin}
\begin{lstlisting}
?- len([a,b,c,d,e,[a,b],g],X).
X = 7
\end{lstlisting}
\end{latin}

این برنامه خوبی است: هم قابل فهم است و هم بهینه. ولی راه دیگری برای پیدا کردن طول لیست وجود دارد و ما می‌خواهیم آن را معرفی کنیم چون از ایده انباره‌ها استفاده می‌کند. با انباره‌ها در فصل قبل به طور مختصر آشنا شدیم. انباره چیزی شبیه استفاده از متغیرها برای ذخیره نتایج مراحل میانی اجرای یک الگوریتم است.

برای یافتن طول لیست، محمول \متن‌لاتین{accLen/3} را تعریف می‌کنیم.

\begin{latin}
\begin{lstlisting}
accLen(List,Acc,Length)
\end{lstlisting}
\end{latin}

در اینجا List لیستی است که می‌خواهیم طول آن را پیدا کنیم و Length طول آن است. Acc چیست؟ این متغیری است که می‌خواهیم از آن برای نگهداری نتایجی که در مراحل میانی بدست می‌آید استفاده کنیم. وقتی که این محمول را صدا می‌زنیم، مقدار اولیه Acc را برابر صفر قرار می‌دهیم. وقتی به طور بازگشتی لیست را پیمایش می‌کنیم، هر بار که head لیست را یافتیم عدد یک را به Acc اضافه می‌کنیم تا زمانی که به یک لیست خالی برسیم که برای آن head تعریف نشده است. در این مرحله Acc برابر طول لیست است. کد برنامه را ببینید:

\begin{latin}
\begin{lstlisting}
accLen([_|T],A,L) :- Anew is A+1, accLen(T,Anew,L).
accLen([],A,A).
\end{lstlisting}
\end{latin}

حالت پایه این تعریف، آرگومان‌های دوم و سوم را متحد می‌کند. چرا؟ دو دلیل برای اینکار وجود دارد. اولین دلیل این است که وقتی به انتهای لیست می‌رسیم مقدار انباره برابر طول لیست است. بنابراین با استفاده از اتحاد، طول لیست را برابر مقدار انباره قرار می‌دهیم. دومین دلیل این است که این اتحاد باعث می‌شود که هنگام برخورد با لیست خالی بازگشت متوقف شود. trace را برای یک مثال با هم می‌بینیم:

\begin{latin}
\begin{lstlisting}
?- accLen([a,b,c],0,L).
Call: (6) accLen([a, b, c], 0, _G449) ?
Call: (7) _G518 is 0+1 ?
Exit: (7) 1 is 0+1 ?
Call: (7) accLen([b, c], 1, _G449) ?
Call: (8) _G521 is 1+1 ?
Exit: (8) 2 is 1+1 ?
Call: (8) accLen([c], 2, _G449) ?
Call: (9) _G524 is 2+1 ?
Exit: (9) 3 is 2+1 ?
Call: (9) accLen([], 3, _G449) ?
Exit: (9) accLen([], 3, 3) ?
Exit: (8) accLen([c], 2, 3) ?
Exit: (7) accLen([b, c], 1, 3) ?
Exit: (6) accLen([a, b, c], 0, 3) ?
\end{lstlisting}
\end{latin}

یک گام دیگر برای تکمیل تعریف باقی مانده و آن ایجاد یک محمول برای مقداردهی اولیه به Acc است:

\begin{latin}
\begin{lstlisting}
leng(List,Length) :- accLen(List,0,Length).
\end{lstlisting}
\end{latin}

حالا می‌توانیم طول یک لیست را مانند مثال زیر بیابیم:

\begin{latin}
\begin{lstlisting}
?- leng([a,b,c,d,e,[a,b],g],X).
X = 7
\end{lstlisting}
\end{latin}

استفاده از ایده انباره‌ها بسیار مهم است و بارها در پرولوگ با این ایده برخورد خواهیم کرد. اما چرا accLen بهتر از len است؟ با اینکه پیچیده‌تر به نظر می‌رسد. پاسخ این است که accLen به اصطلاح \متن‌لاتین{tail recursive} است در حالی که len اینطور نیست. در برنامه‌های \متن‌لاتین{tail recursive} هنگامی که به مرحله آخر بازگشت می‌رسیم تمام پاسخ مورد نیاز را در دست داریم و کافی است آن را به مراحل بالاتر انتقال دهیم. اما در برنامه‌های بازگشتی که \متن‌لاتین{tail recursive} نیستند در هر مرحله از بازگشت یک goal جدید ایجاد می‌کنیم که برای ارضاء آن باید منتظر شکل‌گیری پاسخ در مراحل پایین‌تر بمانیم.

برای اینکه این مفهوم را بهتر درک کنید trace زیر را که برای مثال \متن‌لاتین{len([a,b,c],0,L)} آورده شده با trace قبل که برای \متن‌لاتین{accLen([a,b,c],0,L)} بود مقایسه کنید.

\begin{latin}
\begin{lstlisting}
?- len([a,b,c],L).
Call: (6) len([a, b, c], _G418) ?
Call: (7) len([b, c], _G481) ?
Call: (8) len([c], _G486) ?
Call: (9) len([], _G489) ?
Exit: (9) len([], 0) ?
Call: (9) _G486 is 0+1 ?
Exit: (9) 1 is 0+1 ?
Exit: (8) len([c], 1) ?
Call: (8) _G481 is 1+1 ?
Exit: (8) 2 is 1+1 ?
Exit: (7) len([b, c], 2) ?
Call: (7) _G418 is 2+1 ?
Exit: (7) 3 is 2+1 ?
Exit: (6) len([a, b, c], 3) ?
\end{lstlisting}
\end{latin}

\section{مقایسه اعداد}
بعضی از محمول‌های محاسباتی پرولوگ بدون نیاز به is کار خود را انجام می‌دهند. این محمول‌ها در واقع عملگرهای مقایسه‌ای می‌باشند.

\begin{latin}
\begin{lstlisting}
?- 2 < 4.
yes

?- 2 =< 4.
yes

?- 4 =< 4.
yes

?- 4=:=4.
yes

?- 4=\=4.
no

?- 4=\=5.
yes

?- 4 >= 4.
yes

?- 4 > 2.
yes
\end{lstlisting}
\end{latin}

همانطور که حدس می‌زنید، \متن‌لاتین{=:=} عملگر مساوی و \متن‌لاتین{=\textbackslash=} عملگر نامساوی است. باید توجه داشته باشید که عملگر \متن‌لاتین{=:=} با \متن‌لاتین{=} متفاوت است. به مثال زیر توجه کنید.

\begin{latin}
\begin{lstlisting}
?- 4 = 4.
yes

?- 2+2 = 4.
no

?- 2+2 =:= 4.
yes
\end{lstlisting}
\end{latin}

نکته دیگر در مثال بالا این است که عملگرهای مقایسه باعث می‌شوند عبارت سمت راست و سمت چپ evaluate شوند یعنی عبارات محاسبه شده و نتیجه نهایی در مقایسه بکار می‌رود. به همین دلیل است که \متن‌لاتین{2+2=:=4} جواب yes داد.

هنگامی که از این عملگرها استفاده می‌کنیم باید توجه داشته باشیم که متغیرهای بکار رفته حتماً از قبل مقداردهی شده باشند در غیر این صورت با پیغام خطای مقداردهی مواجه می‌شویم. همچنین متغیرها باید مقدار عدد صحیح داشته باشند. مثلاً 
\begin{latin}
\begin{lstlisting}
X = 3, X < 4.
\end{lstlisting}
\end{latin}

ارضاء پذیر است ولی برای عبارت

\begin{latin}
\begin{lstlisting}
X = b, X < 4.
\end{lstlisting}
\end{latin}

با پاسخ منفی روبرو می‌شویم.

خوب، وقت آن است که از عملگرهای مقایسه‌ای پرولوگ در یک برنامه استفاده کنیم. محمولی را تعریف می‌کنیم که یک لیست از اعداد صحیح غیر منفی دریافت کند و بزرگترین عدد در این لیست را به عنوان آرگومان دوم باز می‌گرداند. در تعریف این محمول بازهم از ایده انباره‌ها استفاده می‌کنیم. در پیمایش لیست، انباره بزرگترین عدد دیده شده تا آن لحظه را نگهداری می‌کند. اگر در پیمایش با یک عدد بزرگتر از انباره برخورد کردیم، انباره را بروزرسانی می‌کنیم. در اجرای این محمول مقدار اولیه انباره را برابر صفر قرار می‌دهیم. کد برنامه به شکل زیر است.

\begin{latin}
\begin{lstlisting}
accMax([H|T],A,Max) :- H > A,
                       accMax(T,H,Max).
accMax([H|T],A,Max) :- H =< A,
                       accMax(T,A,Max).
accMax([],A,A).
\end{lstlisting}
\end{latin}

اولین clause بررسی می‌کند که آیا head‌ لیست از بزرگترین عدد یافت‌شده، بزرگتر است یا خیر. اگر چنین بود، از head به عنوان مقدار جدید انباره استفاده می‌کنیم و کار را با tail‌ به صورت بازگشتی ادامه می‌دهیم. دومین clause جایی بکار می‌رود که head کوچکتر یا مساوی مقدار انباره است. در این حالت از مقدار قبلی انباره برای ادامه کار استفاده می‌کنیم. clause پایه نیز در آخر وظیفه اتحاد بین آرگومان دوم و سوم را برعهده دارد؛ این clause بزرگترین مقدار یافت شده را در آرگومان سوم قرار می‌دهد. trace‌ زیر نحوه اجرای این برنامه را نشان می‌دهد.

\begin{latin}
\begin{lstlisting}
accMax([1,0,5,4],0,_5810)

accMax([0,5,4],1,_5810)

accMax([5,4],1,_5810)

accMax([4],5,_5810)

accMax([],5,_5810)

accMax([],5,5)
\end{lstlisting}
\end{latin}

بازهم خوب است که یک محمول تعریف کنیم که accMax را صدا کند و انباره را مقداردهی اولیه کند. اما مقدار اولیه انباره چه باید باشد؟ اگر مقدار را برابر صفر قرار دهیم، فرض کرده‌ایم تمام اعداد لیست مثبت هستند. اما اگر لیستی از اعداد منفی را به این محمول دادیم چه؟

\begin{latin}
\begin{lstlisting}
?- accMax([-11,-2,-7,-4,-12],0,Max).
Max = 0
yes
\end{lstlisting}
\end{latin}

این چیزی نیست که ما می‌خواهیم: بزرگترین عدد در این لیست \متن‌لاتین{-2} است. استفاده از صفر به عنوان مقدار اولیه برای انباره کار را خراب کرد.

یک راه آسان برای حل این مشکل وجود دارد و آن این است که مقدار اولیه انباره را برابر head لیست قرار دهیم.

\begin{latin}
\begin{lstlisting}
max(List,Max) :- List = [H|_],
                 accMax(List,H,Max).
\end{lstlisting}
\end{latin}

حالا می‌توانیم به راحتی از اعداد منفی هم استفاده کنیم.

\begin{latin}
\begin{lstlisting}
?- max([-11,-2,-7,-4,-12],X).
X = -2
yes
\end{lstlisting}
\end{latin}

\clearpage

\section{تمرین‌ها}
\begin{exercise}
پاسخ پرولوگ به هر کدام از پرسش‌های زیر چیست؟

\begin{latin}
\begin{lstlisting}
X = 3*4.

X is 3*4.

4 is X.

X = Y.

3 is 1+2.

3 is +(1,2).

3 is X+2.

X is 1+2.

1+2 is 1+2.

is(X,+(1,2)).

3+2 = +(3,2).

*(7,5) = 7*5.

*(7,+(3,2)) = 7*(3+2).

*(7,(3+2)) = 7*(3+2).

*(7,(3+2)) = 7*(+(3,2)).
\end{lstlisting}
\end{latin}
\end{exercise}

\begin{exercise}
\begin{enumerate}
\فقره یک محمول تعریف کنید که دو آرگومان به صورت عدد صحیح دریافت کند و فقط وقتی پاسخ درست دهد که آرگومان اول تنها یکی از آرگومان دوم بزرگتر باشد. برای مثال، \متن‌لاتین{increment(4,5)} باید پاسخ درست دهد اما برای \متن‌لاتین{increment(4,6)} پاسخ باید منفی باشد.
\فقره یک محمول با سه آرگومان تعریف کنید که تنها وقتی درست باشد که سومین آرگومانش مجموع دو آرگومان اول باشد. برای مثال \متن‌لاتین{sum(4,5,9)} باید پاسخ مثبت و \متن‌لاتین{sum(4,6,12)} پاسخ منفی دهد.
\end{enumerate}
\end{exercise}

\begin{exercise}
محمول \متن‌لاتین{addone/2} را طوری تعریف کنید که در آرگومان اول یک لیست دریافت کند و به هر عدد در آن لیست یکی اضافه کند و نتیجه را در یک لیست به عنوان آرگومان دوم بازگرداند. به عنوان مثال
\begin{latin}
\begin{lstlisting}
addone([1,2,7,2],X).
\end{lstlisting}
\end{latin}
باید پاسخ
\begin{latin}
\begin{lstlisting}
X = [2,3,8,3].
\end{lstlisting}
\end{latin}
برگرداند.
\end{exercise}

\section{تمرین عملی}
در این قسمت می‌خواهیم کمی با قابلیت‌های ریاضی پرولوگ کار کنیم و کمی بیشتر با لیست‌ها تمرین کنیم.

\begin{enumerate}
\فقره در متن درس محمول \متن‌لاتین{accMax} را تعریف کردیم. با تغییر کد، محمول \متن‌لاتین{accMin} را تعریف کنید که کمینه مقدار یک لیست را برگرداند.
\فقره در ریاضیات، یک بردار n‌ بعدی، یک لیست از اعداد است به طول n. یکی از عمل‌های پایه روی بردارها، ضرب scalar است. یعنی تک تک عنصرهای بردار را در یک عدد صحیح ضرب می‌کنیم. مثلاً ضرب scalar بردار \متن‌لاتین{[2,7,4]} در سه، برابر است با \متن‌لاتین{[6,21,12]}. محمول \متن‌لاتین{scalarMult/3} را طوری تعریف کنید که اولین آرگومانش یک عدد، دومین آرگومانش یک لیست از اعداد و سومین آرگومانش نتیجه ضرب scalar دو آرگومان اول باشد. به عنوان مثال برای
\begin{latin}
\begin{lstlisting}
scalarMult(3,[2,7,4],Result).
\end{lstlisting}
\end{latin}

پاسخ باید به شکل زیر باشد.

\begin{latin}
\begin{lstlisting}
Result = [6,21,12]
\end{lstlisting}
\end{latin}

\فقره یک عمل مهم دیگر بر روی بردارها، عمل ضرب داخلی است. در این عمل، عناصر دو بردار هم اندازه، به ترتیب در هم ضرب شده و تمام نتایج با هم جمع می‌گردد و نتیجه یک عدد خواهد بود. برای بردار \متن‌لاتین{[2,5,6]} و \متن‌لاتین{[3,4,1]} نتیجه برابر خواهد بود با \متن‌لاتین{6+20+6 = 32}. محمول \متن‌لاتین{dot/3} را طوری تعریف کنید که در آرگومان اول و دوم دو لیست هم اندازه دریافت کند و نتیجه ضرب داخلی این دو بردار را به عنوان آرگومان سوم بازگرداند. به مثال زیر توجه کنید.
\begin{latin}
\begin{lstlisting}
?- dot([2,5,6],[3,4,1],Result).
Result = 32
\end{lstlisting}
\end{latin}

\end{enumerate}