\chapter{لیست‌ها}

\section{لیست‌ها}

همانطور که مشخص است، لیست گردایه‌ مرتبی از تعداد متناهی عضو است. در زیر چند نمونه از لیست ها در پرولوگ نمایش داده شده‌اند.

\begin{latin}
\begin{lstlisting}
[mia, vincent, jules, yolanda]

[mia, robber(honey_bunny), X, 2, mia]

[]

[mia, [vincent, jules], [butch, girlfriend(butch)]]

[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]]
\end{lstlisting}
\end{latin}

چند نکته مهم در این مثال‌ها وجود دارد که بهتر است به آنها نگاهی داشته باشیم.

\begin{enumerate}
\فقره یک لیست در پرولوگ با نماد براکت ساخته می‌شود. عضوهای لیست توسط کاما از یکدیگر جدا می‌شوند. طول لیست، عددی است که تعداد اعضای یک لیست را نشان می‌دهد. به عنوان مثال اولین لیست در مثال‌های بالا، دارای طول چهار است.
\فقره از مثال دوم مشخص است که تمام ساختارهای پرولوگ می‌توانند عضوی از لیست باشند. در همین مثال، \متن‌لاتین{mia} یک اتم است، \متن‌لاتین{robber(honey\_bunny)} یک ترم پیچیده است و \متن‌لاتین{X} هم یک متغیر است و حتی یک عدد هم در لیست داریم. علاوه بر این، همانطور که متوجه شده‌اید در این مثال \متن‌لاتین{mia} دو بار در لیست تکرار شده است. پس در پرولوگ اعضای لیست یکتا نیستند.
\فقره مثال سوم نمایش دهنده یک لیست خالی است. طول این لیست صفر است.
\فقره مثال چهارم نشان می‌دهد که لیست‌ها می‌توانند خود عضوی از یک لیست باشند. پس لیست‌ها ساختارهای بازگشتی هستند. اما طول این لیست چیست؟ پاسخ سه است. اگر پاسخی که در ذهن داشتید چیزی بغیر از سه بود باید تعریف و مثال‌های بالا را یکبار دیگر مرور کنید. تعداد اعضای یک لیست، تعداد چیزهایی است که در بین دو براکت آخر قرار دارند و با کاما از هم جدا شده‌اند. پس این لیست سه عضو دارد. اولی \متن‌لاتین{mia}، دومی \متن‌لاتین{[vincent, jules]} و سومی \متن‌لاتین{[butch, girlfriend(butch)]}.
\فقره آخرین مثال، لیستی است که تمام نکته‌های بالا را یکجا در خود جای داده است! این لیست شامل دو لیست خالی، یک ترم پیچیده، دو نمونه از لیست \متن‌لاتین{[2, [b, chopper]]} و متغیر Z است.
\end{enumerate}

حال به مهمترین نکته می‌رسیم. هر لیست غیر تهی را می‌توان به دو بخش head و tail‌ تقسیم بندی کرد. head اولین عضو لیست است و tail شامل بقیه عضوهاست. یعنی tail لیستی است که از حذف اولین عضو از لیست مورد نظر بدست می‌آید. پس tail همواره یک لیست است. برای نمونه head لیست

\begin{latin}
\begin{lstlisting}
[mia, vincent, jules, yolanda]
\end{lstlisting}
\end{latin}

\متن‌لاتین{mia} است و tail آن \متن‌لاتین{[vincent, jules, yolanda]} است. به طور مشابه head لیست

\begin{latin}
\begin{lstlisting}
[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]]
\end{lstlisting}
\end{latin}

\متن‌لاتین{[]} است و tail آن \متن‌لاتین{[dead(zed), [2,[b,chopper]],[],Z,[2,[b, chopper]]]} است. اما در مورد \متن‌لاتین{[dead(zed)]} چه می‌توان گفت؟ از تعریف مشخص است که head در اینجا \متن‌لاتین{dead(zed)} است و tail یک لیست خالی است که از برداشتن اولین عضو لیست مورد نظر پدید می‌آید: \متن‌لاتین{[]}.

باز هم تاکید می‌کنیم که head و tail فقط برای لیست‌های غیر تهی تعریف می‌شود. برای پرولوگ لیست خالی به طور خاص تنها نمایانگر یک لیست است و ساختار داخلی خاصی ندارد.

پرولوگ عملگر خاص | را برای جداسازی یک لیست به head و tail در نظر گرفته است. واضح‌ترین کاربرد | استخراج داده ها از یک لیست است. این کار با استفاده از اتحاد صورت می‌گیرد. به مثال زیر توجه کنید:

\begin{latin}
\begin{lstlisting}
?- [Head | Tail] = [mia, vincent, jules, yolanda].
Head = mia
Tail = [vincent,jules,yolanda]
yes
\end{lstlisting}
\end{latin}

در اینجا head و tail لیست به ترتیب به متغیرهای Head و Tail تعلق گرفت. توجه کنید که Head و Tail‌ در اینجا فقط متغیر هستند. می‌توان به جای آنها از X و Y استفاده کرد:

\begin{latin}
\begin{lstlisting}
?- [X|Y] = [mia, vincent, jules, yolanda].
X = mia
Y = [vincent,jules,yolanda]
yes
\end{lstlisting}
\end{latin}

حال ببینیم که اگر اینکار را روی یک لیست خالی امتحان کنیم چه اتفاقی می‌افتد:

\begin{latin}
\begin{lstlisting}
?- [X|Y] = [].
no
\end{lstlisting}
\end{latin}

همانطور که گفتیم پرولوگ \متن‌لاتین{[]} را به عنوان یک لیست خاص می‌شناسد که برای آن head و tail تعریف نشده‌اند. از این خاصیت بسیار مهم در ادامه استفاده خواهیم کرد.

به چند مثال دیگر نگاهی می‌اندازیم.

\begin{latin}
\begin{lstlisting}
?- [X|Y] = [[], dead(zed), [2, [b, chopper]], [], Z].
X = []
Y = [dead(zed),[2,[b,chopper]],[],_7800]
Z = _7800
yes
\end{lstlisting}
\end{latin}

در اینجا X با head لیست و Y با tail آن مقداردهی شده است. اطلاعاتی هم راجع به متغیر داخلی bind شده به Z نمایش داده شده است.

می‌توانیم از عملگر | استفاده‌های جالبتری داشته باشیم. فرض کنید می‌خواهیم دو عضو اول لیست و سپس مابقی اعضاء را استخراج کنیم.

\begin{latin}
\begin{lstlisting}
?- [X,Y | W] = [[], dead(zed), [2, [b, chopper]], [], Z].
X = []
Y = dead(zed)
W = [[2,[b,chopper]],[],_8327]
Z =_8327
yes
\end{lstlisting}
\end{latin}

در اینجا head لیست به X و عضو دوم لیست به Y تعلق گرفت و مابقی اعضاء از عضو دوم به بعد در متغیر W جای گرفت. بنابراین عملگر | نه تنها می‌تواند برای تقسیم لیست به head و tail مورد استفاده قرار گیرد، بلکه می‌تواند یک لیست را از هر نقطه دلخواهی به دو قسمت تقسیم کند. در سمت چپ | باید تعداد اعضایی را که می‌خواهیم جدا کنیم با چند متغیر مشخص کنیم. در سمت راست | هم متغیری قرار می‌دهیم که مابقی اعضاء‌ در قالب یک لیست به آن نسبت داده شوند.

زمان مناسبی است که متغیر بی‌نام\پانوشت{Anonymous} را معرفی کنیم. فرض کنید می‌خواهیم از لیست زیر عضوهای سوم و چهارم را استخراج کنیم. مشخص است که اینکار به راحتی قابل انجام است:

\begin{latin}
\begin{lstlisting}
?- [X1,X2,X3,X4 | Tail] = [[], dead(zed), [2, [b, chopper]], [], Z].
X1 = []
X2 = dead(zed)
X3 = [2,[b,chopper]]
X4 = []
Tail = [_8910]
Z = _8910
yes
\end{lstlisting}
\end{latin}

متغیرهای \متن‌لاتین{X2} و \متن‌لاتین{X4} مقادیری که ما می‌خواستیم را نگهداری می‌کنند. مشکل اینجاست که مجبور شدیم اطلاعاتی که نمی‌خواهیم هم در متغیرهای \متن‌لاتین{X1} و \متن‌لاتین{X3} و \متن‌لاتین{Tail} و Z بریزیم. وقتی به آنها نیازی نداریم اینکار کمی ناراحت کننده است. راه دیگری برای انجام اینکار در پرولوگ وجود دارد:

\begin{latin}
\begin{lstlisting}
?- [_,X,_,Y|_] = [[], dead(zed), [2, [b, chopper]], [], Z].
X = dead(zed)
Y = []
Z = _9593
yes
\end{lstlisting}
\end{latin}

نماد \متن‌لاتین{\_} (underscore) متغیر بی‌نام است. از این متغیر هنگامی استفاده می‌کنیم که مقدار آن برای ما مهم نیست. همانطور که در بالا مشاهده می‌کنید پرولوگ مقدار نسبت داده شده به متغیر بی‌نام را نمایش نداد. علاوه بر این دقت کنید که هر تکرار \متن‌لاتین{\_} مستقل است: هر کدام از آنها مثل یک متغیر مستقل عمل می‌کنند و مقدارهای متفاوتی می‌گیرند. همانطور که از فصل اول به یاد دارید متغیرهای معمولی چنین قابلیتی ندارند.

به عنوان آخرین مثال، سومین عضو لیست بالا را در نظر بگیرید (\متن‌لاتین{[2, [b, chopper]]}). می‌خواهیم tail این لیست را استخراج کنیم. چطور اینکار را انجام می‌دهیم؟

\begin{latin}
\begin{lstlisting}
?- [_,_,[_|X]|_] =
[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]].
X = [[b,chopper]]
Z = _10087
yes
\end{lstlisting}
\end{latin}

\section{عضویت}

یکی از ابتدایی‌ترین نیازهای ما وقتی با لیست‌ها کار می‌کنیم این است که بدانیم آیا یک چیز عضو لیست داده شده هست یا خیر. پس بیایید برنامه‌ای بنویسیم که یک ترم X و یک لیست L را به عنوان آرگومان دریافت کند و بگوید آیا X عضوی از L هست یا خیر. برنامه‌ای که اینکار را انجام می‌دهد با عنوان member شناخته می‌شود و ساده‌ترین مثالی در پرولوگ است که از ساختار بازگشتی لیست‌ها استفاده می‌کند:

\begin{latin}
\begin{lstlisting}
member(X,[X|T]).
member(X,[H|T]) :- member(X,T).
\end{lstlisting}
\end{latin}

این برنامه ساده متشکل از یک حقیقت و یک قاعده است. البته دقت دارید که این قاعده، یک قاعده بازگشتی است (در هر دو سمت قاعده محمول \متن‌لاتین{member/2} را مشاهده می‌کنید).

کار را با مفهوم منطقی این برنامه شروع می‌کنیم. اولین clause می‌گوید: X عضوی از لیست است اگر در head لیست قرار گرفته باشد. دومین clause می‌گوید: X عضوی از یک لیست است اگر عضوی از tail آن لیست باشد.

این معنی کاملاً قابل درک است. اما آیا این برنامه درست کار می‌کند و کاری که باید را انجام می‌دهد؟ برای پاسخ به این سوال باید در مورد معنی عملکردی این برنامه فکر کنیم. در ابتدا چند مثال را با هم ببینیم:

\begin{latin}
\begin{lstlisting}
?- member(yolanda,[yolanda,trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

پرولوگ بلادرنگ پاسخ yes خواهد داد. چرا؟ به این دلیل که میتواند yolanda را با دو X موجود در clause اول تعریف \متن‌لاتین{member/2} متحد کند.

حالا مثال زیر را در نظر بگیرید:

\begin{latin}
\begin{lstlisting}
?- member(vincent,[yolanda,trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

در اینجا اولین clause بکار نخواهد آمد (yolanda و vincent دو اتم متفاوت هستند) پس پرولوگ کار را با clause دوم ادامه می‌دهد. قاعده بازگشتی باعث ایجاد یک goal جدید برای پرولوگ می‌شود:

\begin{latin}
\begin{lstlisting}
member(vincent,[trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

بار دیگر اولین clause تعریف \متن‌لاتین{member/2} بکار نخواهد آمد. پس پرولوگ باز هم از قاعده بازگشتی استفاده می‌کند و این بار goal زیر ایجاد می‌شود:

\begin{latin}
\begin{lstlisting}
member(vincent,[vincent,jules]).
\end{lstlisting}
\end{latin}

حالا با استفاده از clause اول، این پرسش با پاسخ مثبت همراه می‌شود.

تا اینجای کار خوب بود. اما اگر پرسشی را مطرح کنیم که باید پاسخ منفی داشته باشد چه اتفاقی خواهد افتاد؟ مثال زیر را در نظر بگیرید:

\begin{latin}
\begin{lstlisting}
member(zed,[yolanda,trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

پرولوگ چطور به این پرسش پاسخ می‌دهد؟ چطور باید مطمئن باشیم که پرولوگ در پاسخ به این سوال، گرفتار حلقه نخواهد شد و پاسخ منفی خواهد داد؟ بیایید نحوه کار پرولوگ را بررسی کنیم.

بازهم clause اول بکار نخواهد آمد. پس پرولوگ از قاعده بازگشتی استفاده می‌کند و goal جدیدی ساخته می‌شود:

\begin{latin}
\begin{lstlisting}
member(zed,[trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

بازهم clause اول مفید نیست. پس دوباره از قاعده بازگشتی استفاده می‌کند و goal جدیدی تعریف می‌شود:

\begin{latin}
\begin{lstlisting}
member(zed,[vincent,jules]).
\end{lstlisting}
\end{latin}

و باز هم اتفاقی مشابه مرحله قبل می‌افتد و goal جدید مشخص می‌شود:

\begin{latin}
\begin{lstlisting}
member(zed,[jules]).
\end{lstlisting}
\end{latin}

باز هم اولین clause مفید نیست. این‌بار پرولوگ با استفاده از قاعده بازگشتی goal زیر را ایجاد می‌کند:

\begin{latin}
\begin{lstlisting}
member(zed,[]).
\end{lstlisting}
\end{latin}

مشخص است که اولین clause کمکی نمی‌کند. از دومین clause هم کاری ساخته نیست. چرا؟ چون قاعده بازگشتی، بر اساس تقسیم لیست به دو قسمت head و tail کار می‌کند. ولی در اینجا با لیست خالی مواجه هستیم که قابل تقسیم نیست. پس پرولوگ دست از جستجو می‌کشد و پاسخ no می‌دهد. این پاسخ درستی است زیرا zed در لیست نبود.

تا اینجا دیدیم که محمول \متن‌لاتین{member/2} به درستی کار می‌کند. اما مثال قبل تمام قابلیت‌های این محمول را نشان نمی‌دهد. می‌توانیم پرسش‌های دیگری که شامل متغیرهاست از پرولوگ بپرسیم:

\begin{latin}
\begin{lstlisting}
member(X,[yolanda,trudy,vincent,jules]).
X = yolanda ;
X = trudy ;
X = vincent ;
X = jules ;
no
\end{lstlisting}
\end{latin}

پرولوگ تمام اعضای لیست را نمایش داد. این یکی از کاربردهای مهم \متن‌لاتین{member/2} است. در برنامه‌هایی که با پرولوگ می‌نویسیم به این قابلیت نیاز داریم.

نکته آخر اینکه نحوه تعریف این محمول درست است ولی می‌توان خوانایی آن را افزایش داد. اولین clause تنها با head لیست کار می‌کند ولی ما برای tail هم یک متغیر در نظر گرفته‌ایم. همینطور برای clause دوم، تنها به tail نیاز داریم ولی برای head هم یک متغیر قرار داده‌ایم. این متغیرهای بی استفاده خوانایی برنامه را کاهش می‌دهند. بهتر است برنامه را طوری بنویسیم که تمرکز را روی نقاط مهم هر clause جلب کند، و متغیرهای بی‌نام این امکان را فراهم می‌آورند:

\begin{latin}
\begin{lstlisting}
member(X,[X|_]).
member(X,[_|T]) :- member(X,T).
\end{lstlisting}
\end{latin}

\section{پیمایش بازگشتی لیست}
محمول member با استفاده از پیمایش بازگشتی لیست\پانوشت{\متن‌لاتین{recursing down the list}} کار می‌کند، یعنی ابتدا عملیاتی روی head انجام می‌دهد و سپس از tail به عنوان یک لیست جدید استفاده کرده و با استفاده از تعریف بازگشتی، این عملیات را بر روی تک تک اعضاء به ترتیب انجام می‌دهد. این روش مرسومی در پرولوگ است و به همین دلیل شما باید این ایده را به خوبی فرا بگیرید و در موارد مختلف از آن استفاده کنید. مثال دیگری از این تکنیک را با هم بررسی می‌کنیم.

کار با لیست‌ها معمولاً شامل مقایسه دو لیست، اضافه کردن یک لیست به لیست دیگر و کارهای مشابه است. می‌خواهیم محمول \متن‌لاتین{a2b/2} را طوری تعریف کنیم که دو لیست به عنوان آرگومان دریافت کند و پاسخ yes بدهد اگر لیست اول شامل کاراکترهای a و لیست دوم با همان طول شامل کاراکترهای b باشد. برای مثال اگر پرسش زیر را مطرح کنیم:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],[b,b,b,b]).
\end{lstlisting}
\end{latin}

پرولوگ باید پاسخ مثبت بدهد. و اگر پرسش

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

و یا

\begin{latin}
\begin{lstlisting}
a2b([a,c,a,a],[b,b,5,4]).
\end{lstlisting}
\end{latin}

را مطرح کنیم باید پاسخ منفی بگیریم.

در این موارد بهتر است کار را با در نظر گرفتن ساده‌ترین حالت شروع کنیم. برای لیست‌ها، ساده‌ترین حالت حالتی است که لیست تهی باشد که برای مسئله ما معنی دار است: ساده‌ترین لیست شامل کاراکترهای a یک لیست خالی است! برای لیست شامل b ها هم همینطور. پس تعریف محمول a2b باید شامل حالت زیر باشد:

\begin{latin}
\begin{lstlisting}
a2b([],[]).
\end{lstlisting}
\end{latin}

این حقیقت می‌گوید که دو لیست خالی به تعداد مساوی (صفر) a و b دارند. البته همانطور که خواهیم دید، این قسمت بخش مهمی از تعریف را تشکیل می‌دهد.

تا اینجای کار خوب بود. اما چطور ادامه بدهیم؟ ایده این است که برای لیست‌های بزرگتر، باید به صورت بازگشتی عمل کنیم. چه موقع \متن‌لاتین{a2b/2} باید بگوید که دو لیست غیر تهی دارای طول یکسان هستند و یکی شامل کاراکترهای a و دیگری شامل کاراکترهای b است؟ پاسخ این است: هنگامی که head لیست اول یک a بود و head لیست دوم یک b بود و \متن‌لاتین{a2b/2} بگوید که tail هر دو لیست طول یکسان دارند و یکی شامل کاراکترهای a و دیگری شامل کاراکترهای b است! به زبان پرولوگ:

\begin{latin}
\begin{lstlisting}
a2b([a|Ta],[b|Tb]) :- a2b(Ta,Tb).
\end{lstlisting}
\end{latin}

مفهوم منطقی تعریف این محمول درست است. یک قاعده بازگشتی ساده و طبیعی داریم که در آن clause پایه، لیست‌های تهی و clause بازگشتی، لیست‌های غیرتهی را بررسی می‌کند. بیایید معنی عملکردی این محمول را بررسی کنیم. فرض کنید که سوال زیر را مطرح کنیم:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

پرولوگ باید پاسخ مثبت بدهد. در این مثال هیچ کدام از لیست‌ها تهی نیستند، پس clause پایه کاربردی ندارد. پرولوگ از clause دوم استفاده می‌کند و goal جدید ایجاد می‌شود:

\begin{latin}
\begin{lstlisting}
a2b([a,a],[b,b]).
\end{lstlisting}
\end{latin}

بازهم برای پاسخ به این goal، نمی‌توان از clause پایه استفاده کرد. استفاده مجدد از clause بازگشتی منجر به ایجاد goal زیر می‌شود:

\begin{latin}
\begin{lstlisting}
a2b([a],[b]).
\end{lstlisting}
\end{latin}

باز هم پرولوگ باید از clause بازگشتی استفاده نماید، در نتیجه goal جدیدی بدست می‌آید:

\begin{latin}
\begin{lstlisting}
a2b([],[]).
\end{lstlisting}
\end{latin}

در آخر از حقیقت یا clause پایه استفاده می‌شود و goal جدید ارضاء می‌گردد.  چون این goal ارضاء شد پس goal مرحله قبل هم ارضاء می‌شود:


\begin{latin}
\begin{lstlisting}
a2b([a],[b]).
\end{lstlisting}
\end{latin}

و همینطور goal قبل‌تر

\begin{latin}
\begin{lstlisting}
a2b([a,a],[b,b]).
\end{lstlisting}
\end{latin}

و goal اصلی هم ارضاء می‌گردد:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

حالا می‌توانید پاسخ دهید که چرا تعریف بازگشتی محمول \متن‌لاتین{a2b/2} پایان‌پذیر است. به این دلیل که در هر مرحله از بازگشت، با لیستی سر و کار داریم که یکی از طولش کم شده است. پس به جایی خواهیم رسید که حداقل یکی از لیست‌ها خالی خواهد شد و از حقیقتی که تعریف کردیم استفاده می‌کنیم تا پاسخ درستی به سوال مورد نظر بدهیم.

حالا بیایید مثالی را در نظر بگیریم که باید با پاسخ منفی روبرو شود. برای مثال اگر پرسش زیر را مطرح کنیم:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

پرولوگ به درستی پاسخ منفی خواهد داد. زیرا که با سه بار استفاده از قاعده بازگشتی به goal زیر می‌رسد:

\begin{latin}
\begin{lstlisting}
a2b([a],[]).
\end{lstlisting}
\end{latin}

و این goal ارضاپذیر نیست پس پاسخ منفی خواهد بود. به طور مشابه پرسش زیر نیز باید با پاسخ منفی همراه باشد:

\begin{latin}
\begin{lstlisting}
a2b([a,c,a,a],[b,b,5,4]).
\end{lstlisting}
\end{latin}

این‌بار با اجرای قاعده بازگشتی به goal زیر می‌رسیم که ارضاپذیر نیست و پرولوگ پاسخ منفی می‌دهد:

\begin{latin}
\begin{lstlisting}
a2b([c,a,a],[b,5,4]).
\end{lstlisting}
\end{latin}

مثل همیشه می‌توان به جای پرسش‌های بله یا خیر، پرسش‌های بهتری از پرولوگ پرسید. اگر در پرسش از یک متغیر استفاده کنیم چه اتفاقی می‌افتد؟

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],X).
\end{lstlisting}
\end{latin}

در این حالت پرولوگ مثل یک مبدل، کاراکترهای a را به کاراکترهای b تغییر می‌دهد و پاسخ زیر را خواهید دید:

\begin{latin}
\begin{lstlisting}
X = [b,b,b,b].
\end{lstlisting}
\end{latin}

حال اگر به جای هر دو آرگومان از دو متغیر استفاده کنیم چه اتفاقی می‌افتد؟

\begin{latin}
\begin{lstlisting}
a2b(X,Y).
\end{lstlisting}
\end{latin}

سعی کنید به این سوال پاسخ دهید.

محمول \متن‌لاتین{a2b/2} یک مثال از پیمایش بازگشتی لیست‌ها بود به این معنی که از ابتدا تا انتهای لیست را پیمایش کرده و روی اعضای آن عملیات خاصی را انجام می‌دهیم. در مثال مورد نظر ما این عملیات در واقع مقایسه دو عضو لیست‌های ورودی بود. هر چند این مثال ساده بود ولی تکنیک مهمی در برنامه نویسی پرولوگ را به نمایش گذاشت. در فرآیند برنامه نویسی برای پرولوگ از این تکنیک بارها و بارها استفاده خواهید کرد.

\section{الحاق}

می‌خواهیم محمول \متن‌لاتین{append/3} را تعریف کنیم که تمام آرگومان‌های آن لیست هستند. از نگاه توصیفی، \متن‌لاتین{append(L1,L2,L3)} درست است اگر L3 نتیجه الحاق L1 و L2 به یکدیگر باشد. منظور از الحاق دو لیست، اضافه کردن یک لیست به انتهای دیگری است. برای مثال پرسش
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],[a,b,c,1,2,3]).
\end{lstlisting}
\end{latin}
و یا
\begin{latin}
\begin{lstlisting}
?- append([a,[foo,gibble],c],[1,2,[[],b]],
   [a,[foo,gibble],c,1,2,[1,2,[[],b]]).
\end{lstlisting}
\end{latin}
با پاسخ مثبت همراه هستند. برعکس، برای پرسش
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],[a,b,c,1,2]).
\end{lstlisting}
\end{latin}
یا
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],[1,2,3,a,b,c]).
\end{lstlisting}
\end{latin}
پاسخ منفی است.

از نگاه عملکردی، ساده‌ترین کاربرد append الحاق دو لیست به یکدیگر است. اکنون دیگر می‌دانید که اینکار با استفاده از یک متغیر در آرگومان سوم صورت می‌پذیرد.
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],L3).
L3 = [a,b,c,1,2,3]
yes
\end{lstlisting}
\end{latin}
ولی همانطور که خواهیم دید از این محمول برای جداسازی لیست‌ها هم می‌توان استفاده کرد. در واقع کارهای زیادی می‌توان با این محمول انجام داد که مطالعه آنها در درک پردازش لیست در پرولوگ به ما کمک می‌کند.

\subsection{تعریف محمول الحاق}
محمول الحاق به شکل زیر تعریف می‌شود:
\begin{latin}
\begin{lstlisting}
append([],L,L).
append([H|T],L2,[H|L3]) :- append(T,L2,L3).
\end{lstlisting}
\end{latin}
این یک تعریف بازگشتی است. clause پایه ساده‌ترین حالت یعنی الحاق یک لیست خالی به لیست دیگر را نشان می‌دهد. واضح است که در این حالت نتیجه الحاق، همان لیست غیر تهی است.

برای clause بازگشتی، باید گفت که در اینجا می‌خواهیم لیست غیر تهی \متن‌لاتین{[H|T]} را به \متن‌لاتین{L2} اضافه کنیم. نتیجه لیستی خواهد بود که head آن H و tail آن نتیجه الحاق T و \متن‌لاتین{L2} است. در شکل زیر این روند را می‌بینید.

\begin{latin}
\begin{tikzpicture}[node distance=0.2cm,
label/.style={align=left,text width=3cm},
head/.style={rectangle,draw,align=center,text width=0.5cm},
tail/.style={rectangle,draw,align=center,text width=4cm}]
    \node[label] (0) {L1:};
    \node[head] (1) {H};
    \node[tail] (2) [right=0.2cm of 1] {T};
    \node[label] (3) [below=0.2cm of 0] {L2:};
    \node[tail] (4) [below right=0.2cm and 0cm of 2] {L2};
    \node[label] (5) [below=0.2cm of 3] {Recursion:};
    \node[tail] (6) [below=1cm of 2] {T};
    \node[tail] (7) [below=0.2cm of 4] {L2};
    \node[label] (8) [below=0.2cm of 5] {L3:};
    \node[head] (9) [below=1.8cm of 1] {H};
    \node[tail] (10) [below=0.2cm of 6] {T};
    \node[tail] (11) [right=0cm of 10] {L2};

\end{tikzpicture}
\end{latin}

طبق روال باید معنی عملکردی تعریف بازگشتی را بررسی کنیم. فرض کنید پرسش \متن‌لاتین{append([a,b,c],[1,2,3],X)} را از پرولوگ پرسیده‌ایم. 
\section{معکوس کردن لیست}


\clearpage

\section{تمرین‌ها}

\begin{exercise}
پاسخ پرولوگ به هر کدام از پرسش‌های زیر چیست؟

\begin{latin}
\begin{lstlisting}
[a,b,c,d] = [a,[b,c,d]].
[a,b,c,d] = [a|[b,c,d]].
[a,b,c,d] = [a,b,[c,d]].
[a,b,c,d] = [a,b|[c,d]].
[a,b,c,d] = [a,b,c,[d]].
[a,b,c,d] = [a,b,c|[d]].
[a,b,c,d] = [a,b,c,d,[]].
[a,b,c,d] = [a,b,c,d|[]].
[] = _.
[] = [_].
[] = [_|[]].
\end{lstlisting}
\end{latin}

\end{exercise}

\begin{exercise}
پایگاه داده زیر را در نظر بگیرید.

\begin{latin}
\begin{lstlisting}
tran(eins,one).
tran(zwei,two).
tran(drei,three).
tran(vier,four).
tran(fuenf,five).
tran(sechs,six).
tran(sieben,seven).
tran(acht,eight).
tran(neun,nine).
\end{lstlisting}
\end{latin}

محمول \متن‌لاتین{listtran(G,E)} را طوری تعریف کنید که اعداد آلمانی را به معادل انگلیسی آنها ترجمه کند. مثال زیر را در نظر بگیرید.

\begin{latin}
\begin{lstlisting}
?- listtran([eins,neun,zwei],X).
X = [one,nine,two].
yes
\end{lstlisting}
\end{latin}

دقت کنید که این محمول باید بتواند اعداد انگلیسی را هم به معادل آلمانی آنها ترجمه کند یعنی:

\begin{latin}
\begin{lstlisting}
?- listtran(X,[one,seven,six,two]).
X = [eins,sieben,sechs,zwei].
yes
\end{lstlisting}
\end{latin}

راهنمایی: ابتدا ساده‌ترین حالت یعنی لیست خالی را در نظر بگیرید. سپس سعی کنید برای لیست‌های بزرگتر اول head را ترجمه کرده و سپس بقیه لیست را ترجمه کنید.
\end{exercise}

\begin{exercise}
محمول \متن‌لاتین{twice(In,Out)} را طوری تعریف کنید که آرگومان سمت چپ یک لیست باشد و آرگومان سمت راست لیستی باشد از اعضای لیست اول که هر کدام دوبار تکرار شده‌اند. برای مثال:

\begin{latin}
\begin{lstlisting}
?- twice([1,2,1,1],X).
X = [1,1,2,2,1,1,1,1].
yes
\end{lstlisting}
\end{latin}

\end{exercise}

\begin{exercise}
درخت جستجو را برای پرسش‌های زیر رسم کنید.

\begin{latin}
\begin{lstlisting}
?- member(a,[c,b,a,y]).
?- member(x,[a,b,c]).
?- member(X,[a,b,c]).
\end{lstlisting}
\end{latin}

\end{exercise}

\section{تمرین عملی}

هدف از این بخش تمرین تکنیک پیمایش بازگشتی لیست است. در ابتدا محمول \متن‌لاتین{a2b/2} را پیاده سازی کرده و سعی کنید با استفاده از دستور trace نحوه کار این محمول را بخصوص در موارد زیر ببینید:

\begin{enumerate}
\فقره چند پرسش فاقد متغیر را بررسی کنید. مثلاً \متن‌لاتین{a2b([a,a,a,a],[b,b,b,b])} 
\فقره پرسشی را بررسی کنید که باید پاسخ منفی دریافت کنید. برای اینکار می‌توانید از پرسش‌های متن درس استفاده کنید.
\فقره پرسشی را بررسی کنید که شامل متغیر باشد. مثلاً \متن‌لاتین{a2b([a,a,a,a],X)} را trace کنید.
\فقره حالتی را بررسی کنید که هر دو آرگومان متغیر باشند.
\فقره پرسش‌های مشابه بالا را برای محمول \متن‌لاتین{member/2} بکار ببرید و نحوه رسیدن به پاسخ را با trace بررسی کنید.
\end{enumerate}

حال که این موارد را خوب بررسی کردید وقت آن است که از این تکنیک در برنامه نویسی استفاده کنید.

\begin{enumerate}
\فقره محمول \متن‌لاتین{combine1/3} را طوری بنویسید که سه لیست را به عنوان آرگومان دریافت کند و عضوهای دو لیست اول را به لیست سوم اضافه کند.
\begin{latin}
\begin{lstlisting}
?- combine1([a,b,c],[1,2,3],X).
X = [a,1,b,2,c,3].
yes

?- combine1([foo,bar,yip,yup],[glub,glab,glib,glob],Result).
Result = [foo,glub,bar,glab,yip,glib,yup,glob].
yes
\end{lstlisting}
\end{latin}

\فقره محمول \متن‌لاتین{combine2/3} را طوری تعریف کنید که سه لیست به عنوان آرگومان دریافت کند و عضوهای دو لیست اول را به شکل زیر به لیست سوم اضافه کند.
\begin{latin}
\begin{lstlisting}
?- combine2([a,b,c],[1,2,3],X).
X = [[a,1],[b,2],[c,3]].
yes

?- combine2([foo,bar,yip,yup],[glub,glab,glib,glob],Result).
Result = [[foo,glub],[bar,glab],[yip,glib],[yup,glob]].
yes
\end{lstlisting}
\end{latin}

\فقره محمول \متن‌لاتین{combine3/3} را طوری تعریف کنید که سه لیست به عنوان آرگومان دریافت کند و عضوهای دو لیست اول را به شکل زیر به لیست سوم اضافه کند.
\begin{latin}
\begin{lstlisting}
?- combine3([a,b,c],[1,2,3],X).
X = [join(a,1),join(b,2),join(c,3)].
yes

?- combine3([foo,bar,yip,yup],[glub,glab,glib,glob],R).
R = [join(foo,glub),join(bar,glab),join(yip,glib),join(yup,glob)].
yes
\end{lstlisting}
\end{latin}

\end{enumerate}

هر سه تمرین بالا درست همانند محمول \متن‌لاتین{a2b/2} نوشته می‌شوند با این تفاوت که اینجا با سه لیست سر و کار داریم. اما تکنیک همان است. دو مسئله بعدی کمی جالبتر هستند. برای حل آنها می‌توانید از محمول \متن‌لاتین{member/2} استفاده کنید.

\begin{enumerate}
\فقره محمول \متن‌لاتین{mysubset/2} را طوری تعریف کنید که دو لیست از ثوابت به عنوان آرگومان دریافت کند و تعیین کند که آیا آرگومان اول زیر مجموعه‌ای از آرگومان دوم هست یا خیر.
\فقره محمول \متن‌لاتین{mysuperset/2} را طوری تعریف کنید که دو لیست به عنوان آرگومان دریافت کند و تعیین کند که آیا آرگومان اول سوپرست آرگومان دوم هست یا خیر.
\end{enumerate}
