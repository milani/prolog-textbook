\chapter{لیست‌ها}

\section{لیست‌ها}

همانطور که مشخص است، لیست گردایه‌ مرتبی از تعداد متناهی عضو است. در زیر چند نمونه از لیست ها در پرولوگ نمایش داده شده‌اند.

\begin{latin}
\begin{lstlisting}
[mia, vincent, jules, yolanda]

[mia, robber(honey_bunny), X, 2, mia]

[]

[mia, [vincent, jules], [butch, girlfriend(butch)]]

[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]]
\end{lstlisting}
\end{latin}

چند نکته مهم در این مثال‌ها وجود دارد که بهتر است به آنها نگاهی داشته باشیم.

\begin{enumerate}
\فقره یک لیست در پرولوگ با نماد براکت ساخته می‌شود. عضوهای لیست توسط کاما از یکدیگر جدا می‌شوند. طول لیست، عددی است که تعداد اعضای یک لیست را نشان می‌دهد. به عنوان مثال اولین لیست در مثال‌های بالا، دارای طول چهار است.
\فقره از مثال دوم مشخص است که تمام ساختارهای پرولوگ می‌توانند عضوی از لیست باشند. در همین مثال، \متن‌لاتین{mia} یک اتم است، \متن‌لاتین{robber(honey\_bunny)} یک ترم پیچیده است و \متن‌لاتین{X} هم یک متغیر است و حتی یک عدد هم در لیست داریم. علاوه بر این، همانطور که متوجه شده‌اید در این مثال \متن‌لاتین{mia} دو بار در لیست تکرار شده است. پس در پرولوگ اعضای لیست یکتا نیستند.
\فقره مثال سوم نمایش دهنده یک لیست خالی است. طول این لیست صفر است.
\فقره مثال چهارم نشان می‌دهد که لیست‌ها می‌توانند خود عضوی از یک لیست باشند. پس لیست‌ها ساختارهای بازگشتی هستند. اما طول این لیست چیست؟ پاسخ سه است. اگر پاسخی که در ذهن داشتید چیزی بغیر از سه بود باید تعریف و مثال‌های بالا را یکبار دیگر مرور کنید. تعداد اعضای یک لیست، تعداد چیزهایی است که در بین دو براکت آخر قرار دارند و با کاما از هم جدا شده‌اند. پس این لیست سه عضو دارد. اولی \متن‌لاتین{mia}، دومی \متن‌لاتین{[vincent, jules]} و سومی \متن‌لاتین{[butch, girlfriend(butch)]}.
\فقره آخرین مثال، لیستی است که تمام نکته‌های بالا را یکجا در خود جای داده است! این لیست شامل دو لیست خالی، یک ترم پیچیده، دو نمونه از لیست \متن‌لاتین{[2, [b, chopper]]} و متغیر Z است.
\end{enumerate}

حال به مهمترین نکته می‌رسیم. هر لیست غیر تهی را می‌توان به دو بخش head و tail‌ تقسیم بندی کرد. head اولین عضو لیست است و tail شامل بقیه عضوهاست. یعنی tail لیستی است که از حذف اولین عضو از لیست مورد نظر بدست می‌آید. پس tail همواره یک لیست است. برای نمونه head لیست

\begin{latin}
\begin{lstlisting}
[mia, vincent, jules, yolanda]
\end{lstlisting}
\end{latin}

\متن‌لاتین{mia} است و tail آن \متن‌لاتین{[vincent, jules, yolanda]} است. به طور مشابه head لیست

\begin{latin}
\begin{lstlisting}
[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]]
\end{lstlisting}
\end{latin}

\متن‌لاتین{[]} است و tail آن \متن‌لاتین{[dead(zed), [2,[b,chopper]],[],Z,[2,[b, chopper]]]} است. اما در مورد \متن‌لاتین{[dead(zed)]} چه می‌توان گفت؟ از تعریف مشخص است که head در اینجا \متن‌لاتین{dead(zed)} است و tail یک لیست خالی است که از برداشتن اولین عضو لیست مورد نظر پدید می‌آید: \متن‌لاتین{[]}.

باز هم تاکید می‌کنیم که head و tail فقط برای لیست‌های غیر تهی تعریف می‌شود. برای پرولوگ لیست خالی به طور خاص تنها نمایانگر یک لیست است و ساختار داخلی خاصی ندارد.

پرولوگ عملگر خاص | را برای جداسازی یک لیست به head و tail در نظر گرفته است. واضح‌ترین کاربرد | استخراج داده ها از یک لیست است. این کار با استفاده از اتحاد صورت می‌گیرد. به مثال زیر توجه کنید:

\begin{latin}
\begin{lstlisting}
?- [Head | Tail] = [mia, vincent, jules, yolanda].
Head = mia
Tail = [vincent,jules,yolanda]
yes
\end{lstlisting}
\end{latin}

در اینجا head و tail لیست به ترتیب به متغیرهای Head و Tail تعلق گرفت. توجه کنید که Head و Tail‌ در اینجا فقط متغیر هستند. می‌توان به جای آنها از X و Y استفاده کرد:

\begin{latin}
\begin{lstlisting}
?- [X|Y] = [mia, vincent, jules, yolanda].
X = mia
Y = [vincent,jules,yolanda]
yes
\end{lstlisting}
\end{latin}

حال ببینیم که اگر اینکار را روی یک لیست خالی امتحان کنیم چه اتفاقی می‌افتد:

\begin{latin}
\begin{lstlisting}
?- [X|Y] = [].
no
\end{lstlisting}
\end{latin}

همانطور که گفتیم پرولوگ \متن‌لاتین{[]} را به عنوان یک لیست خاص می‌شناسد که برای آن head و tail تعریف نشده‌اند. از این خاصیت بسیار مهم در ادامه استفاده خواهیم کرد.

به چند مثال دیگر نگاهی می‌اندازیم.

\begin{latin}
\begin{lstlisting}
?- [X|Y] = [[], dead(zed), [2, [b, chopper]], [], Z].
X = []
Y = [dead(zed),[2,[b,chopper]],[],_7800]
Z = _7800
yes
\end{lstlisting}
\end{latin}

در اینجا X با head لیست و Y با tail آن مقداردهی شده است. اطلاعاتی هم راجع به متغیر داخلی bind شده به Z نمایش داده شده است.

می‌توانیم از عملگر | استفاده‌های جالبتری داشته باشیم. فرض کنید می‌خواهیم دو عضو اول لیست و سپس مابقی اعضاء را استخراج کنیم.

\begin{latin}
\begin{lstlisting}
?- [X,Y | W] = [[], dead(zed), [2, [b, chopper]], [], Z].
X = []
Y = dead(zed)
W = [[2,[b,chopper]],[],_8327]
Z =_8327
yes
\end{lstlisting}
\end{latin}

در اینجا head لیست به X و عضو دوم لیست به Y تعلق گرفت و مابقی اعضاء از عضو دوم به بعد در متغیر W جای گرفت. بنابراین عملگر | نه تنها می‌تواند برای تقسیم لیست به head و tail مورد استفاده قرار گیرد، بلکه می‌تواند یک لیست را از هر نقطه دلخواهی به دو قسمت تقسیم کند. در سمت چپ | باید تعداد اعضایی را که می‌خواهیم جدا کنیم با چند متغیر مشخص کنیم. در سمت راست | هم متغیری قرار می‌دهیم که مابقی اعضاء‌ در قالب یک لیست به آن نسبت داده شوند.

زمان مناسبی است که متغیر بی‌نام\پانوشت{Anonymous} را معرفی کنیم. فرض کنید می‌خواهیم از لیست زیر عضوهای سوم و چهارم را استخراج کنیم. مشخص است که اینکار به راحتی قابل انجام است:

\begin{latin}
\begin{lstlisting}
?- [X1,X2,X3,X4 | Tail] = [[], dead(zed), [2, [b, chopper]], [], Z].
X1 = []
X2 = dead(zed)
X3 = [2,[b,chopper]]
X4 = []
Tail = [_8910]
Z = _8910
yes
\end{lstlisting}
\end{latin}

متغیرهای \متن‌لاتین{X2} و \متن‌لاتین{X4} مقادیری که ما می‌خواستیم را نگهداری می‌کنند. مشکل اینجاست که مجبور شدیم اطلاعاتی که نمی‌خواهیم هم در متغیرهای \متن‌لاتین{X1} و \متن‌لاتین{X3} و \متن‌لاتین{Tail} و Z بریزیم. وقتی به آنها نیازی نداریم اینکار کمی ناراحت کننده است. راه دیگری برای انجام اینکار در پرولوگ وجود دارد:

\begin{latin}
\begin{lstlisting}
?- [_,X,_,Y|_] = [[], dead(zed), [2, [b, chopper]], [], Z].
X = dead(zed)
Y = []
Z = _9593
yes
\end{lstlisting}
\end{latin}

نماد \متن‌لاتین{\_} (underscore) متغیر بی‌نام است. از این متغیر هنگامی استفاده می‌کنیم که مقدار آن برای ما مهم نیست. همانطور که در بالا مشاهده می‌کنید پرولوگ مقدار نسبت داده شده به متغیر بی‌نام را نمایش نداد. علاوه بر این دقت کنید که هر تکرار \متن‌لاتین{\_} مستقل است: هر کدام از آنها مثل یک متغیر مستقل عمل می‌کنند و مقدارهای متفاوتی می‌گیرند. همانطور که از فصل اول به یاد دارید متغیرهای معمولی چنین قابلیتی ندارند.

به عنوان آخرین مثال، سومین عضو لیست بالا را در نظر بگیرید (\متن‌لاتین{[2, [b, chopper]]}). می‌خواهیم tail این لیست را استخراج کنیم. چطور اینکار را انجام می‌دهیم؟

\begin{latin}
\begin{lstlisting}
?- [_,_,[_|X]|_] =
[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]].
X = [[b,chopper]]
Z = _10087
yes
\end{lstlisting}
\end{latin}

\section{عضویت}

یکی از ابتدایی‌ترین نیازهای ما وقتی با لیست‌ها کار می‌کنیم این است که بدانیم آیا یک چیز عضو لیست داده شده هست یا خیر. پس بیایید برنامه‌ای بنویسیم که یک ترم X و یک لیست L را به عنوان آرگومان دریافت کند و بگوید آیا X عضوی از L هست یا خیر. برنامه‌ای که اینکار را انجام می‌دهد با عنوان member شناخته می‌شود و ساده‌ترین مثالی در پرولوگ است که از ساختار بازگشتی لیست‌ها استفاده می‌کند:

\begin{latin}
\begin{lstlisting}
member(X,[X|T]).
member(X,[H|T]) :- member(X,T).
\end{lstlisting}
\end{latin}

این برنامه ساده متشکل از یک حقیقت و یک قاعده است. البته دقت دارید که این قاعده، یک قاعده بازگشتی است (در هر دو سمت قاعده محمول \متن‌لاتین{member/2} را مشاهده می‌کنید).

کار را با مفهوم منطقی این برنامه شروع می‌کنیم. اولین clause می‌گوید: X عضوی از لیست است اگر در head لیست قرار گرفته باشد. دومین clause می‌گوید: X عضوی از یک لیست است اگر عضوی از tail آن لیست باشد.

این معنی کاملاً قابل درک است. اما آیا این برنامه درست کار می‌کند و کاری که باید را انجام می‌دهد؟ برای پاسخ به این سوال باید در مورد معنی عملکردی این برنامه فکر کنیم. در ابتدا چند مثال را با هم ببینیم:

\begin{latin}
\begin{lstlisting}
?- member(yolanda,[yolanda,trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

پرولوگ بلادرنگ پاسخ yes خواهد داد. چرا؟ به این دلیل که میتواند yolanda را با دو X موجود در clause اول تعریف \متن‌لاتین{member/2} متحد کند.

حالا مثال زیر را در نظر بگیرید:

\begin{latin}
\begin{lstlisting}
?- member(vincent,[yolanda,trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

در اینجا اولین clause بکار نخواهد آمد (yolanda و vincent دو اتم متفاوت هستند) پس پرولوگ کار را با clause دوم ادامه می‌دهد. قاعده بازگشتی باعث ایجاد یک goal جدید برای پرولوگ می‌شود:

\begin{latin}
\begin{lstlisting}
member(vincent,[trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

بار دیگر اولین clause تعریف \متن‌لاتین{member/2} بکار نخواهد آمد. پس پرولوگ باز هم از قاعده بازگشتی استفاده می‌کند و این بار goal زیر ایجاد می‌شود:

\begin{latin}
\begin{lstlisting}
member(vincent,[vincent,jules]).
\end{lstlisting}
\end{latin}

حالا با استفاده از clause اول، این پرسش با پاسخ مثبت همراه می‌شود.

تا اینجای کار خوب بود. اما اگر پرسشی را مطرح کنیم که باید پاسخ منفی داشته باشد چه اتفاقی خواهد افتاد؟ مثال زیر را در نظر بگیرید:

\begin{latin}
\begin{lstlisting}
member(zed,[yolanda,trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

پرولوگ چطور به این پرسش پاسخ می‌دهد؟ چطور باید مطمئن باشیم که پرولوگ در پاسخ به این سوال، گرفتار حلقه نخواهد شد و پاسخ منفی خواهد داد؟ بیایید نحوه کار پرولوگ را بررسی کنیم.

بازهم clause اول بکار نخواهد آمد. پس پرولوگ از قاعده بازگشتی استفاده می‌کند و goal جدیدی ساخته می‌شود:

\begin{latin}
\begin{lstlisting}
member(zed,[trudy,vincent,jules]).
\end{lstlisting}
\end{latin}

بازهم clause اول مفید نیست. پس دوباره از قاعده بازگشتی استفاده می‌کند و goal جدیدی تعریف می‌شود:

\begin{latin}
\begin{lstlisting}
member(zed,[vincent,jules]).
\end{lstlisting}
\end{latin}

و باز هم اتفاقی مشابه مرحله قبل می‌افتد و goal جدید مشخص می‌شود:

\begin{latin}
\begin{lstlisting}
member(zed,[jules]).
\end{lstlisting}
\end{latin}

باز هم اولین clause مفید نیست. این‌بار پرولوگ با استفاده از قاعده بازگشتی goal زیر را ایجاد می‌کند:

\begin{latin}
\begin{lstlisting}
member(zed,[]).
\end{lstlisting}
\end{latin}

مشخص است که اولین clause کمکی نمی‌کند. از دومین clause هم کاری ساخته نیست. چرا؟ چون قاعده بازگشتی، بر اساس تقسیم لیست به دو قسمت head و tail کار می‌کند. ولی در اینجا با لیست خالی مواجه هستیم که قابل تقسیم نیست. پس پرولوگ دست از جستجو می‌کشد و پاسخ no می‌دهد. این پاسخ درستی است زیرا zed در لیست نبود.

تا اینجا دیدیم که محمول \متن‌لاتین{member/2} به درستی کار می‌کند. اما مثال قبل تمام قابلیت‌های این محمول را نشان نمی‌دهد. می‌توانیم پرسش‌های دیگری که شامل متغیرهاست از پرولوگ بپرسیم:

\begin{latin}
\begin{lstlisting}
member(X,[yolanda,trudy,vincent,jules]).
X = yolanda ;
X = trudy ;
X = vincent ;
X = jules ;
no
\end{lstlisting}
\end{latin}

پرولوگ تمام اعضای لیست را نمایش داد. این یکی از کاربردهای مهم \متن‌لاتین{member/2} است. در برنامه‌هایی که با پرولوگ می‌نویسیم به این قابلیت نیاز داریم.

نکته آخر اینکه نحوه تعریف این محمول درست است ولی می‌توان خوانایی آن را افزایش داد. اولین clause تنها با head لیست کار می‌کند ولی ما برای tail هم یک متغیر در نظر گرفته‌ایم. همینطور برای clause دوم، تنها به tail نیاز داریم ولی برای head هم یک متغیر قرار داده‌ایم. این متغیرهای بی استفاده خوانایی برنامه را کاهش می‌دهند. بهتر است برنامه را طوری بنویسیم که تمرکز را روی نقاط مهم هر clause جلب کند، و متغیرهای بی‌نام این امکان را فراهم می‌آورند:

\begin{latin}
\begin{lstlisting}
member(X,[X|_]).
member(X,[_|T]) :- member(X,T).
\end{lstlisting}
\end{latin}

\section{پیمایش بازگشتی لیست}
محمول member با استفاده از پیمایش بازگشتی لیست\پانوشت{\متن‌لاتین{recursing down the list}} کار می‌کند، یعنی ابتدا عملیاتی روی head انجام می‌دهد و سپس از tail به عنوان یک لیست جدید استفاده کرده و با استفاده از تعریف بازگشتی، این عملیات را بر روی تک تک اعضاء به ترتیب انجام می‌دهد. این روش مرسومی در پرولوگ است و به همین دلیل شما باید این ایده را به خوبی فرا بگیرید و در موارد مختلف از آن استفاده کنید. مثال دیگری از این تکنیک را با هم بررسی می‌کنیم.

کار با لیست‌ها معمولاً شامل مقایسه دو لیست، اضافه کردن یک لیست به لیست دیگر و کارهای مشابه است. می‌خواهیم محمول \متن‌لاتین{a2b/2} را طوری تعریف کنیم که دو لیست به عنوان آرگومان دریافت کند و پاسخ yes بدهد اگر لیست اول شامل کاراکترهای a و لیست دوم با همان طول شامل کاراکترهای b باشد. برای مثال اگر پرسش زیر را مطرح کنیم:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],[b,b,b,b]).
\end{lstlisting}
\end{latin}

پرولوگ باید پاسخ مثبت بدهد. و اگر پرسش

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

و یا

\begin{latin}
\begin{lstlisting}
a2b([a,c,a,a],[b,b,5,4]).
\end{lstlisting}
\end{latin}

را مطرح کنیم باید پاسخ منفی بگیریم.

در این موارد بهتر است کار را با در نظر گرفتن ساده‌ترین حالت شروع کنیم. برای لیست‌ها، ساده‌ترین حالت حالتی است که لیست تهی باشد که برای مسئله ما معنی دار است: ساده‌ترین لیست شامل کاراکترهای a یک لیست خالی است! برای لیست شامل b ها هم همینطور. پس تعریف محمول a2b باید شامل حالت زیر باشد:

\begin{latin}
\begin{lstlisting}
a2b([],[]).
\end{lstlisting}
\end{latin}

این حقیقت می‌گوید که دو لیست خالی به تعداد مساوی (صفر) a و b دارند. البته همانطور که خواهیم دید، این قسمت بخش مهمی از تعریف را تشکیل می‌دهد.

تا اینجای کار خوب بود. اما چطور ادامه بدهیم؟ ایده این است که برای لیست‌های بزرگتر، باید به صورت بازگشتی عمل کنیم. چه موقع \متن‌لاتین{a2b/2} باید بگوید که دو لیست غیر تهی دارای طول یکسان هستند و یکی شامل کاراکترهای a و دیگری شامل کاراکترهای b است؟ پاسخ این است: هنگامی که head لیست اول یک a بود و head لیست دوم یک b بود و \متن‌لاتین{a2b/2} بگوید که tail هر دو لیست طول یکسان دارند و یکی شامل کاراکترهای a و دیگری شامل کاراکترهای b است! به زبان پرولوگ:

\begin{latin}
\begin{lstlisting}
a2b([a|Ta],[b|Tb]) :- a2b(Ta,Tb).
\end{lstlisting}
\end{latin}

مفهوم منطقی تعریف این محمول درست است. یک قاعده بازگشتی ساده و طبیعی داریم که در آن clause پایه، لیست‌های تهی و clause بازگشتی، لیست‌های غیرتهی را بررسی می‌کند. بیایید معنی عملکردی این محمول را بررسی کنیم. فرض کنید که سوال زیر را مطرح کنیم:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

پرولوگ باید پاسخ مثبت بدهد. در این مثال هیچ کدام از لیست‌ها تهی نیستند، پس clause پایه کاربردی ندارد. پرولوگ از clause دوم استفاده می‌کند و goal جدید ایجاد می‌شود:

\begin{latin}
\begin{lstlisting}
a2b([a,a],[b,b]).
\end{lstlisting}
\end{latin}

بازهم برای پاسخ به این goal، نمی‌توان از clause پایه استفاده کرد. استفاده مجدد از clause بازگشتی منجر به ایجاد goal زیر می‌شود:

\begin{latin}
\begin{lstlisting}
a2b([a],[b]).
\end{lstlisting}
\end{latin}

باز هم پرولوگ باید از clause بازگشتی استفاده نماید، در نتیجه goal جدیدی بدست می‌آید:

\begin{latin}
\begin{lstlisting}
a2b([],[]).
\end{lstlisting}
\end{latin}

در آخر از حقیقت یا clause پایه استفاده می‌شود و goal جدید ارضاء می‌گردد.  چون این goal ارضاء شد پس goal مرحله قبل هم ارضاء می‌شود:


\begin{latin}
\begin{lstlisting}
a2b([a],[b]).
\end{lstlisting}
\end{latin}

و همینطور goal قبل‌تر

\begin{latin}
\begin{lstlisting}
a2b([a,a],[b,b]).
\end{lstlisting}
\end{latin}

و goal اصلی هم ارضاء می‌گردد:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

حالا می‌توانید پاسخ دهید که چرا تعریف بازگشتی محمول \متن‌لاتین{a2b/2} پایان‌پذیر است. به این دلیل که در هر مرحله از بازگشت، با لیستی سر و کار داریم که یکی از طولش کم شده است. پس به جایی خواهیم رسید که حداقل یکی از لیست‌ها خالی خواهد شد و از حقیقتی که تعریف کردیم استفاده می‌کنیم تا پاسخ درستی به سوال مورد نظر بدهیم.

حالا بیایید مثالی را در نظر بگیریم که باید با پاسخ منفی روبرو شود. برای مثال اگر پرسش زیر را مطرح کنیم:

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],[b,b,b]).
\end{lstlisting}
\end{latin}

پرولوگ به درستی پاسخ منفی خواهد داد. زیرا که با سه بار استفاده از قاعده بازگشتی به goal زیر می‌رسد:

\begin{latin}
\begin{lstlisting}
a2b([a],[]).
\end{lstlisting}
\end{latin}

و این goal ارضاپذیر نیست پس پاسخ منفی خواهد بود. به طور مشابه پرسش زیر نیز باید با پاسخ منفی همراه باشد:

\begin{latin}
\begin{lstlisting}
a2b([a,c,a,a],[b,b,5,4]).
\end{lstlisting}
\end{latin}

این‌بار با اجرای قاعده بازگشتی به goal زیر می‌رسیم که ارضاپذیر نیست و پرولوگ پاسخ منفی می‌دهد:

\begin{latin}
\begin{lstlisting}
a2b([c,a,a],[b,5,4]).
\end{lstlisting}
\end{latin}

مثل همیشه می‌توان به جای پرسش‌های بله یا خیر، پرسش‌های بهتری از پرولوگ پرسید. اگر در پرسش از یک متغیر استفاده کنیم چه اتفاقی می‌افتد؟

\begin{latin}
\begin{lstlisting}
a2b([a,a,a,a],X).
\end{lstlisting}
\end{latin}

در این حالت پرولوگ مثل یک مبدل، کاراکترهای a را به کاراکترهای b تغییر می‌دهد و پاسخ زیر را خواهید دید:

\begin{latin}
\begin{lstlisting}
X = [b,b,b,b].
\end{lstlisting}
\end{latin}

حال اگر به جای هر دو آرگومان از دو متغیر استفاده کنیم چه اتفاقی می‌افتد؟

\begin{latin}
\begin{lstlisting}
a2b(X,Y).
\end{lstlisting}
\end{latin}

سعی کنید به این سوال پاسخ دهید.

محمول \متن‌لاتین{a2b/2} یک مثال از پیمایش بازگشتی لیست‌ها بود به این معنی که از ابتدا تا انتهای لیست را پیمایش کرده و روی اعضای آن عملیات خاصی را انجام می‌دهیم. در مثال مورد نظر ما این عملیات در واقع مقایسه دو عضو لیست‌های ورودی بود. هر چند این مثال ساده بود ولی تکنیک مهمی در برنامه نویسی پرولوگ را به نمایش گذاشت. در فرآیند برنامه نویسی برای پرولوگ از این تکنیک بارها و بارها استفاده خواهید کرد.

\section{الحاق}

می‌خواهیم محمول \متن‌لاتین{append/3} را تعریف کنیم که تمام آرگومان‌های آن لیست هستند. از نگاه توصیفی، \متن‌لاتین{append(L1,L2,L3)} درست است اگر L3 نتیجه الحاق L1 و L2 به یکدیگر باشد. منظور از الحاق دو لیست، اضافه کردن یک لیست به انتهای دیگری است. برای مثال پرسش
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],[a,b,c,1,2,3]).
\end{lstlisting}
\end{latin}
و یا
\begin{latin}
\begin{lstlisting}
?- append([a,[foo,gibble],c],[1,2,[[],b]],
   [a,[foo,gibble],c,1,2,[1,2,[[],b]]).
\end{lstlisting}
\end{latin}
با پاسخ مثبت همراه هستند. برعکس، برای پرسش
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],[a,b,c,1,2]).
\end{lstlisting}
\end{latin}
یا
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],[1,2,3,a,b,c]).
\end{lstlisting}
\end{latin}
پاسخ منفی است.

از نگاه عملکردی، ساده‌ترین کاربرد append الحاق دو لیست به یکدیگر است. اکنون دیگر می‌دانید که این‌کار با استفاده از یک متغیر در آرگومان سوم صورت می‌پذیرد.
\begin{latin}
\begin{lstlisting}
?- append([a,b,c],[1,2,3],L3).
L3 = [a,b,c,1,2,3]
yes
\end{lstlisting}
\end{latin}
ولی همانطور که خواهیم دید از این محمول برای جداسازی لیست‌ها هم می‌توان استفاده کرد. در واقع کارهای زیادی می‌توان با این محمول انجام داد که مطالعه آنها در درک پردازش لیست با پرولوگ به ما کمک می‌کند.

\subsection{تعریف محمول الحاق}
محمول الحاق به شکل زیر تعریف می‌شود:
\begin{latin}
\begin{lstlisting}
append([],L,L).
append([H|T],L2,[H|L3]) :- append(T,L2,L3).
\end{lstlisting}
\end{latin}
این یک تعریف بازگشتی است. clause پایه، ساده‌ترین حالت یعنی الحاق یک لیست خالی به لیست دیگر را نشان می‌دهد. واضح است که در این حالت نتیجه الحاق، همان لیست غیر تهی است.

برای clause بازگشتی، باید گفت که در اینجا می‌خواهیم لیست غیر تهی \متن‌لاتین{[H|T]} را به \متن‌لاتین{L2} اضافه کنیم. نتیجه لیستی خواهد بود که head آن H و tail آن نتیجه الحاق T و \متن‌لاتین{L2} است. در شکل زیر این روند را می‌بینید.

\begin{latin}
\begin{tikzpicture}[node distance=0.2cm,
label/.style={align=left,text width=3cm},
head/.style={rectangle,draw,align=center,text width=0.5cm},
tail/.style={rectangle,draw,align=center,text width=4cm}]
    \node[label] (0) {L1:};
    \node[head] (1) {H};
    \node[tail] (2) [right=0.2cm of 1] {T};
    \node[label] (3) [below=0.2cm of 0] {L2:};
    \node[tail] (4) [below right=0.2cm and 0cm of 2] {L2};
    \node[label] (5) [below=0.2cm of 3] {Recursion:};
    \node[tail] (6) [below=1cm of 2] {T};
    \node[tail] (7) [below=0.2cm of 4] {L2};
    \node[label] (8) [below=0.2cm of 5] {L3:};
    \node[head] (9) [below=1.8cm of 1] {H};
    \node[tail] (10) [below=0.2cm of 6] {T};
    \node[tail] (11) [right=0cm of 10] {L2};

\end{tikzpicture}
\end{latin}

طبق روال باید معنی عملکردی تعریف بازگشتی را بررسی کنیم. فرض کنید پرسش \متن‌لاتین{append([a,b,c],[1,2,3],X)} را از پرولوگ پرسیده‌ایم. پرولوگ این پرسش را با head قاعده بازگشتی متحد می‌کند، و در این بین متغیر داخلی (مثلاً  \متن‌لاتین{\_G518}) ساخته می‌شود. مراحل اجرا به شکل زیر خواهد بود:

\begin{latin}
\begin{lstlisting}
append([a, b, c], [1, 2, 3], _G518)
append([b, c], [1, 2, 3], _G587)
append([c], [1, 2, 3], _G590)
append([], [1, 2, 3], _G593)
append([], [1, 2, 3], [1, 2, 3])
append([c], [1, 2, 3], [c, 1, 2, 3])
append([b, c], [1, 2, 3], [b, c, 1, 2, 3])
append([a, b, c], [1, 2, 3], [a, b, c, 1, 2, 3])
X = [a, b, c, 1, 2, 3]
yes
\end{lstlisting}
\end{latin}

در چهار خط اول، پرولوگ طی استفاده پی در پی از قاعده بازگشتی به مرحله‌ای می‌رسد که آرگومان اول به یک لیست خالی تبدیل شده و می‌تواند از clause پایه استفاده کند. در چهار خط بعد مراحل پر کردن لیست در آرگومان سوم نشان داده شده‌است. برای درک بهتر مراحل پر کردن لیست، درخت جستجو در زیر آورده شده‌است. به مقداردهی متغیرها در این درخت توجه کنید.

\begin{latin}
\begin{tikzpicture}[node distance=2cm,node/.style={ellipse,draw,align=center}]
    \node[node] (1) {append([a,b,c],[1,2,3], \_G518)};
    \node[node] (2) [below of=1] {append([b,c],[1,2,3], \_G587)};
    \node[node] (3) [below of=2] {append([c],[1,2,3], \_G590)};
    \node[node] (4) [below of=3] {append([],[1,2,3], \_G593)};
    \node[node] (5) [below of=4] {};
    \path (1) edge node [left] {\_G518 = [a| \_G587]} (2);
    \path (2) edge node [left] {\_G587 = [b| \_G590]} (3);
    \path (3) edge node [left] {\_G590 = [c| \_G593]} (4);
    \path (4) edge node [left] {\_G593 = []} (5);
\end{tikzpicture}
\end{latin}

این درخت را به دقت بررسی کنید و مطمئن شوید که نحوه مقداردهی متغیرها را که شبیه شکل زیر است فهمیده‌اید. این مثال نحوه ساختن ساختار به صورت بازگشتی در پرولوگ را نشان داد.

\begin{latin}
\begin{lstlisting}
_G518 = [a|_G587]
      = [a|[b|_G590]]
      = [a|[b|[c|_G593]]]
\end{lstlisting}
\end{latin}

\subsection{استفاده از append}

حال که می‌دانیم عملگر الحاق چطور کار می‌کند، خوب است با چند کاربرد مختلف از آن آشنا شویم.

یکی از کاربردهای append شکستن یک لیست به دو قسمت است.

\begin{latin}
\begin{lstlisting}
append(X,Y,[a,b,c,d]).

X = []
Y = [a,b,c,d] ;

X = [a]
Y = [b,c,d] ;

X = [a,b]
Y = [c,d] ;

X = [a,b,c]
Y = [d] ;

X = [a,b,c,d]
Y = [] ;

no
\end{lstlisting}
\end{latin}

در واقع لیست اصلی که می‌خواهیم به دو قسمت تقسیم شود را به عنوان آرگومان سوم به append می‌دهیم و از دو متغیر برای آرگومان‌های اول و دوم استفاده می‌کنیم. در این حالت پرولوگ سعی می‌کند متغیرها را طوری مقداردهی کند که نتیجه الحاق آن دو، معادل لیست اصلی شود. علاوه بر این پرولوگ با استفاده از backtracking تمام حالت‌های ممکن برای تقسیم لیست را جستجو می‌کند.

با استفاده از این خاصیت append می‌توان محمول‌های پرکاربردی ساخت. با هم چند مثال را می‌بینیم. اولین مثال، استفاده از append برای یافتن تمام پیشوندهای یک لیست است. برای لیست \متن‌لاتین{[a,b,c,d]}، تمام پیشوندها عبارت‌اند از \متن‌لاتین{[]}، \متن‌لاتین{[a]}، \متن‌لاتین{[a,b]}، \متن‌لاتین{[a,b,c]} و \متن‌لاتین{[a,b,c,d]}. محمول \متن‌لاتین{prefix/2} را طوری تعریف می‌کنیم که دو لیست به عنوان آرگومان دریافت کند  به طوری که آرگومان اول پیشوند آرگومان دوم باشد.

\begin{latin}
\begin{lstlisting}
prefix(P,L) :- append(P,_,L).
\end{lstlisting}
\end{latin}

این تعریف می‌گوید P یک پیشوند برای لیست L است اگر لیستی وجود داشته باشد که نتیجه اضافه کردن P به آن، L را نتیجه بدهد (از متغیر بی‌نام استفاده کردیم چون لیست میانی برای ما مهم نیست بلکه تنها وجود آن برای ما مهم است). این محمول با استفاده از backtracking تمام پیشوندهای ممکن را چاپ می‌کند.

\begin{latin}
\begin{lstlisting}
prefix(X,[a,b,c,d]).
X = [] ;
X = [a] ;
X = [a,b] ;
X = [a,b,c] ;
X = [a,b,c,d] ;
no
\end{lstlisting}
\end{latin}

به همین ترتیب می‌توان محمول \متن‌لاتین{suffix/2} را ساخت. همانطور که از نامش پیداست، این محمول تمام پسوندهای یک لیست را چاپ می‌کند:

\begin{latin}
\begin{lstlisting}
suffix(S,L) :- append(_,S,L).
\end{lstlisting}
\end{latin}

در اینجا S پسوندی از لیست L است. این محمول هم با استفاده از backtracking تمام پسوندهای ممکن را چاپ می‌کند:

\begin{latin}
\begin{lstlisting}
suffix(X,[a,b,c,d]).
X = [a,b,c,d] ;
X = [b,c,d] ;
X = [c,d] ;
X = [d] ;
X = [] ;
no
\end{lstlisting}
\end{latin}

آیا می‌دانید چرا ترتیب لیست‌های خروجی به این صورت است؟ سعی کنید به این پرسش پاسخ دهید.

حالا تعریف برنامه‌ای که تمام زیرلیست‌های یک لیست را چاپ کند آسان است. مثلاً برای لیست \متن‌لاتین{[a,b,c,d]} پاسخ \متن‌لاتین{[]}، \متن‌لاتین{[a]}، \متن‌لاتین{[b]}، \متن‌لاتین{[c]}، \متن‌لاتین{[d]}، \متن‌لاتین{[a,b]}، \متن‌لاتین{[b,c]}، \متن‌لاتین{[c,d]}، \متن‌لاتین{[d,e]}، \متن‌لاتین{[a,b,c]}، \متن‌لاتین{[b,c,d]} و \متن‌لاتین{[a,b,c,d]} است. با کمی دقت مشخص است که زیرلیست‌های یک لیست، مجموعه تمام پیشوندها و پسوندهای یک لیست است. و ما تمام عناصر لازم برای ساخت این محمول را در اختیار داریم.

\begin{latin}
\begin{lstlisting}
sublist(SubL,L) :- suffix(S,L),prefix(SubL,S).
\end{lstlisting}
\end{latin}

در اینجا، SubL یک زیرلیست برای L است اگر پسوند S برای L وجود داشته باشد که SubL پیشوند S باشد. هرچند که در این برنامه مستقیماً از append استفاده نکردیم اما در واقع کار اصلی را append انجام می‌دهد زیرا هم suffix و هم prefix از append ساخته شده‌اند.

\section{معکوس کردن لیست}
\متن‌لاتین{append} یک محمول بسیار کاربردی است. اما مهم است که بدانید این محمول معمولاً باعث عدم کارایی لازم است و به همین دلیل شاید نخواهیم همیشه از آن استفاده کنیم.

اما چرا append کارا نیست؟ اگر به نحوه کار آن دقت کنید دلیل این عدم کارایی واضح است: append دو لیست را در یک عمل به هم ملحق نمی‌کند بلکه تمام لیست را با یک اجرای بازگشتی پیمایش می‌کند تا به انتهای آن برسد و آنگاه است که در بازگشت، دو لیست را مرحله به مرحله به یکدیگر می‌چسباند.

این کار همیشه ایجاد مشکل نمی‌کند. مثلاً اگر تنها دو لیست داشته باشیم و بخواهیم آن‌ها را به هم ملحق کنیم و طول لیست اول زیاد نباشد، سادگی append کارایی ضعیفش را تا حدی می‌پوشاند.

اما در حالتی که دو آرگومان اول append به صورت متغیر هستند مشکل ایجاد می‌شود. همانطور که دیدیدم از این حالت برای تقسیم یک لیست استفاده می‌شود. پرولوگ برای یافتن پاسخ، جستجوی سنگینی انجام می‌دهد که باعث ناکارایی برنامه می‌شود.

برای اینکه مسئله بهتر مشخص شود، محمول reverse را در نظر بگیرید. کار این محمول این است که یک لیست مثل \متن‌لاتین{[a,b,c,d]} را دریافت کند و لیستی با همان طول ولی به صورت معکوس  مثل \متن‌لاتین{[d,c,b,a]} تولید کند.

در پرولوگ دسترسی به عناصر لیست از ابتدای آن بسیار آسانتر از دسترسی به عناصری است که در انتها هستند. برای مثال، تمام کاری که لازم است انجام دهیم تا عنصر اول یک لیست را بدست آوریم ایجاد اتحاد \متن‌لاتین{[H|\_] = L} است که باعث می‌شود H برابر عنصر اول لیست L مقداردهی شود. اما اینکار برای بدست آوردن عنصر انتهای لیست کافی نیست. یک راه ساده، معکوس کردن لیست و سپس استفاده از اتحاد قبل برای یافتن عنصر ابتدای لیست جدید است که همان عنصر انتهایی لیست اولیه است. اما چطور می‌توان محمول reverse را به صورت بهینه تعریف کرد؟

در ادامه، ابتدا محمول reverse ابتدایی را تعریف می‌کنیم که از append استفاده می‌کند. سپس یک پیاده‌سازی بهینه از reverse ارائه می‌دهیم.

\subsection{تعریف reverse با استفاده از append}
تعریف بازگشتی محمول reverse به این صورت است:
\begin{enumerate}
\فقره اگر یک لیست تهی را معکوس کنیم، نتیجه یک لیست تهی است.
\فقره اگر لیست \متن‌لاتین{[H|T]} را معکوس کنیم، نتیجه برابر است با معکوس لیست T که H را به آن اضافه کنیم.
\end{enumerate}

برای آزمایش قسمت بازگشتی تعریف بالا، لیست \متن‌لاتین{[a,b,c,d]} را در نظر بگیرید. اگر tail این لیست را معکوس کنیم خواهیم داشت \متن‌لاتین{[d,c,b]}. الحاق \متن‌لاتین{[a]} به این لیست برابر خواهد بود با \متن‌لاتین{[d,c,b,a]} که برابر است با معکوس \متن‌لاتین{[a,b,c,d]}. با استفاده از append می‌توان تعریف بالا را به برنامه پرولوگ تبدیل کرد:

\begin{latin}
\begin{lstlisting}
naiverev([],[]).
naiverev([H|T],R) :- naiverev(T,RevT),append(RevT,[H],R).
\end{lstlisting}
\end{latin}

هرچند که تعریف بالا بدرستی کار می‌کند، اما اگر از trace برای نمایش مراحل اجرای آن استفاده کنید خواهید دید که کار زیادی انجام می‌گیرد. و این نشان می‌دهد که سرعت اجرای این برنامه پایین خواهد بود. مثلاً برای معکوس کردن یک لیست ۸تایی، ۹۰ مرحله لازم است.

\subsection{محمول reverse با استفاده از انباره}
راه بهتر برای تعریف reverse استفاده از انباره\پانوشت{accumulator} است. ایده خیلی ساده است. انباره ما یک لیست است که در ابتدای کار تهی است. فرض کنید می‌خواهیم \متن‌لاتین{[a,b,c,d]} را معکوس کنیم. در شروع انباره \متن‌لاتین{[]} است. در ابتدا head لیست مورد نظر را گرفته و در head انباره اضافه می‌کنیم. پس انباره به شکل \متن‌لاتین{[a]} در می‌آید. کار را با معکوس کردن tail لیست یعنی \متن‌لاتین{[b,c,d]}ادامه می‌دهیم. بازهم head لیست را گرفته و آن را به انباره اضافه می‌کنیم (حالا انباره برابر \متن‌لاتین{[b,a]} است) و کار را با tail لیست یعنی \متن‌لاتین{[c,d]} ادامه می‌دهیم. باز هم با استفاده از همان ایده، انباره به شکل \متن‌لاتین{[c,b,a]} و لیست اصلی به شکل \متن‌لاتین{[d]} در می‌آیند. و در مرحله آخر انباره به شکل \متن‌لاتین{[d,c,b,a]} درخواهد آمد و لیست اصلی تهی خواهد شد. این جایی است که اجرا متوقف می‌شود و خروجی مورد نظر ما در انباره قرار دارد! در زیر مراحل اجرا را می‌بینیم.

\begin{latin}
\begin{lstlisting}
List: [a,b,c,d] Accumulator: []
List: [b,c,d]   Accumulator: [a]
List: [c,d]     Accumulator: [b,a]
List: [d]       Accumulator: [c,b,a]
List: []        Accumulator: [d,c,b,a]
\end{lstlisting}
\end{latin}

دلیل بهینه بودن این روش مشخص است. در این تعریف طول لیست را تنها یک بار پیمایش می‌کنیم و زمانی برای الحاق‌های اضافی صرف نمی‌کنیم.

اجرای این ایده در پرولوگ ساده است. کد انباره را در زیر می‌بینیم:
\begin{latin}
\begin{lstlisting}
accRev([H|T],A,R) :- accRev(T,[H|A],R).
accRev([],A,A).
\end{lstlisting}
\end{latin}

در نحوه کار این محمول بازگشتی کمی تأمل کنید. در زیر محمول reverse را تعریف می‌کنیم:
\begin{latin}
\begin{lstlisting}
reverse(L,R) :- accRev(L,[],R).
\end{lstlisting}
\end{latin}

با استفاده از دستور trace این برنامه را با naivrev مقایسه کنید. به وضوح مشخص است که این برنامه بهتر کار می‌کند. برای مثال این برنامه برای معکوس یک لیست ۸ تایی تنها ۲۰ مرحله نیاز دارد ولی naivrev اینکار را در ۹۰ مرحله انجام می‌دهد. علاوه بر این، دنبال کردن نحوه اجرای برنامه در این حالت بسیار ساده‌تر است.

در مجموع باید گفت که append یک محمول بسیار پرکاربرد است و نباید از آن ترسید. ولی باید بدانید که این محمول معمولاً محل ناکارایی برنامه است پس همیشه سعی کنید دنبال راه حل بهتری باشید.

\clearpage

\section{تمرین‌ها}

\begin{exercise}
پاسخ پرولوگ به هر کدام از پرسش‌های زیر چیست؟

\begin{latin}
\begin{lstlisting}
[a,b,c,d] = [a,[b,c,d]].
[a,b,c,d] = [a|[b,c,d]].
[a,b,c,d] = [a,b,[c,d]].
[a,b,c,d] = [a,b|[c,d]].
[a,b,c,d] = [a,b,c,[d]].
[a,b,c,d] = [a,b,c|[d]].
[a,b,c,d] = [a,b,c,d,[]].
[a,b,c,d] = [a,b,c,d|[]].
[] = _.
[] = [_].
[] = [_|[]].
\end{lstlisting}
\end{latin}

\end{exercise}

\begin{exercise}
پایگاه داده زیر را در نظر بگیرید.

\begin{latin}
\begin{lstlisting}
tran(eins,one).
tran(zwei,two).
tran(drei,three).
tran(vier,four).
tran(fuenf,five).
tran(sechs,six).
tran(sieben,seven).
tran(acht,eight).
tran(neun,nine).
\end{lstlisting}
\end{latin}

محمول \متن‌لاتین{listtran(G,E)} را طوری تعریف کنید که اعداد آلمانی را به معادل انگلیسی آنها ترجمه کند. مثال زیر را در نظر بگیرید.

\begin{latin}
\begin{lstlisting}
?- listtran([eins,neun,zwei],X).
X = [one,nine,two].
yes
\end{lstlisting}
\end{latin}

دقت کنید که این محمول باید بتواند اعداد انگلیسی را هم به معادل آلمانی آنها ترجمه کند یعنی:

\begin{latin}
\begin{lstlisting}
?- listtran(X,[one,seven,six,two]).
X = [eins,sieben,sechs,zwei].
yes
\end{lstlisting}
\end{latin}

راهنمایی: ابتدا ساده‌ترین حالت یعنی لیست خالی را در نظر بگیرید. سپس سعی کنید برای لیست‌های بزرگتر اول head را ترجمه کرده و سپس بقیه لیست را ترجمه کنید.
\end{exercise}

\begin{exercise}
محمول \متن‌لاتین{twice(In,Out)} را طوری تعریف کنید که آرگومان سمت چپ یک لیست باشد و آرگومان سمت راست لیستی باشد از اعضای لیست اول که هر کدام دوبار تکرار شده‌اند. برای مثال:

\begin{latin}
\begin{lstlisting}
?- twice([1,2,1,1],X).
X = [1,1,2,2,1,1,1,1].
yes
\end{lstlisting}
\end{latin}

\end{exercise}

\begin{exercise}
درخت جستجو را برای پرسش‌های زیر رسم کنید.

\begin{latin}
\begin{lstlisting}
?- member(a,[c,b,a,y]).
?- member(x,[a,b,c]).
?- member(X,[a,b,c]).
\end{lstlisting}
\end{latin}

\end{exercise}

\begin{exercise}
یک لیست را doubled گوییم اگر از دو قسمت با عناصر کاملاً یکسان که پشت هم قرار گرفته‌اند ساخته شده باشد. لیست \متن‌لاتین{[a,b,c,a,b,c]} یک لیست doubled است. ولی \متن‌لاتین{[foo,gubble,foo]} لیست doubled‌ نیست. محمول \متن‌لاتین{doubled(List)} را طوری تعریف کنید که اگر لیست doubled بود پاسخ yes دهد.
\end{exercise}

\begin{exercise}
یک palindrome کلمه یا عبارتی است که از سمت راست و سمت چپ به یک شکل  نوشته می‌شود. مثلاً rotator یا eve یا \متن‌لاتین{nurses run} همگی palindrome هستند. محمول \متن‌لاتین{palindrome(List)} را طوری تعریف کنید که تشخیص بدهد آیا List یک palindrome است یا خیر.
\begin{latin}
\begin{lstlisting}
?- palindrome([r,o,t,a,t,o,r]).
yes

?- palindrome([n,u,r,s,e,s,r,u,n]).
yes

?- palindrome([n,o,t,h,i,s]).
no
\end{lstlisting}
\end{latin}
\end{exercise}

\begin{exercise}
\begin{enumerate}
\فقره محمول \متن‌لاتین{second(X,List)} را طوری تعریف کنید که بررسی کند آیا X دومین عنصر از List هست یا خیر.
\فقره محمول \متن‌لاتین{swap12(List1,List2)} را طوری تعریف کنید که چک کند آیا List1 با List2 یکسان هست یا خیر، به غیر از دو عنصر اول که باید جا به جا شده باشند.
\فقره محمول \متن‌لاتین{final(X,List)} را طوری تعریف کنید که بررسی کند X عنصر آخر List باشد.
\فقره محمول \متن‌لاتین{toptail(InList,OutList)} را تعریف کنید به طوری که اگر InList کمتر از دو عنصر داشت پاسخ no بدهد و در غیر این صورت عنصر ابتدایی و عنصر ابتدایی آن را حذف کرده و نتیجه را در OutList قرار دهد. راهنمایی: از append استفاده کنید.
\begin{latin}
\begin{lstlisting}
?- toptail([a],T).
no

?- toptail([a,b],T).
T=[]

?- toptail([a,b,c],T).
T=[b]
\end{lstlisting}
\end{latin}
\فقره محمول \متن‌لاتین{swapfl(List1,List2)} را تعریف کنید به طوری که List1 و List2 یکسان باشند به غیر از عنصر اولی و آخری که باید جا به جا شده باشند. راهنمایی: از append استفاده کنید.
\end{enumerate}
\end{exercise}

\begin{exercise}
خیابانی هست که در آن سه خانه در همسایگی هم قرار دارند و هر کدام رنگی متفاوت دارند: قرمز و آبی و سبز. خانواده‌هایی با ملیت‌های متفاوت در این سه خانه زندگی می‌کنند و هر کدام حیوان خانگی متفاوتی دارند.
\begin{enumerate}
\فقره مرد انگلیسی در خانه قرمز زندگی می‌کند.
\فقره خانواده اسپانیایی از یک پلنگ نگهداری می‌کنند.
\فقره ژاپنی ها در سمت راست خانواده‌ای هستند که مار نگهداری می‌کنند.
\فقره خانواده‌ای که مار نگهداری می‌کنند در سمت چپ خانه آبی قرار دارند.
\end{enumerate}
چه کسی گورخر نگهداری می‌کند؟ محمول \متن‌لاتین{zebra/1} را طوری تعریف کنید که ملیت نگهدارنده گورخر را به عنوان خروجی چاپ کند. راهنمایی: در مورد نحوه نمایش خیابان و خانه‌ها فکر کنید. شاید لازم باشد از محمول‌های member و sublist استفاده کنید.
\end{exercise}
\section{تمرین عملی}

هدف از این بخش تمرین تکنیک پیمایش بازگشتی لیست است. در ابتدا محمول \متن‌لاتین{a2b/2} را پیاده سازی کرده و سعی کنید با استفاده از دستور trace نحوه کار این محمول را بخصوص در موارد زیر ببینید:

\begin{enumerate}
\فقره چند پرسش فاقد متغیر را بررسی کنید. مثلاً \متن‌لاتین{a2b([a,a,a,a],[b,b,b,b])} 
\فقره پرسشی را بررسی کنید که باید پاسخ منفی دریافت کنید. برای اینکار می‌توانید از پرسش‌های متن درس استفاده کنید.
\فقره پرسشی را بررسی کنید که شامل متغیر باشد. مثلاً \متن‌لاتین{a2b([a,a,a,a],X)} را trace کنید.
\فقره حالتی را بررسی کنید که هر دو آرگومان متغیر باشند.
\فقره پرسش‌های مشابه بالا را برای محمول \متن‌لاتین{member/2} بکار ببرید و نحوه رسیدن به پاسخ را با trace بررسی کنید.
\end{enumerate}

حال که این موارد را خوب بررسی کردید وقت آن است که از این تکنیک در برنامه نویسی استفاده کنید.

\begin{enumerate}
\فقره محمول \متن‌لاتین{combine1/3} را طوری بنویسید که سه لیست را به عنوان آرگومان دریافت کند و عضوهای دو لیست اول را به لیست سوم اضافه کند.
\begin{latin}
\begin{lstlisting}
?- combine1([a,b,c],[1,2,3],X).
X = [a,1,b,2,c,3].
yes

?- combine1([foo,bar,yip,yup],[glub,glab,glib,glob],Result).
Result = [foo,glub,bar,glab,yip,glib,yup,glob].
yes
\end{lstlisting}
\end{latin}

\فقره محمول \متن‌لاتین{combine2/3} را طوری تعریف کنید که سه لیست به عنوان آرگومان دریافت کند و عضوهای دو لیست اول را به شکل زیر به لیست سوم اضافه کند.
\begin{latin}
\begin{lstlisting}
?- combine2([a,b,c],[1,2,3],X).
X = [[a,1],[b,2],[c,3]].
yes

?- combine2([foo,bar,yip,yup],[glub,glab,glib,glob],Result).
Result = [[foo,glub],[bar,glab],[yip,glib],[yup,glob]].
yes
\end{lstlisting}
\end{latin}

\فقره محمول \متن‌لاتین{combine3/3} را طوری تعریف کنید که سه لیست به عنوان آرگومان دریافت کند و عضوهای دو لیست اول را به شکل زیر به لیست سوم اضافه کند.
\begin{latin}
\begin{lstlisting}
?- combine3([a,b,c],[1,2,3],X).
X = [join(a,1),join(b,2),join(c,3)].
yes

?- combine3([foo,bar,yip,yup],[glub,glab,glib,glob],R).
R = [join(foo,glub),join(bar,glab),join(yip,glib),join(yup,glob)].
yes
\end{lstlisting}
\end{latin}

\end{enumerate}

هر سه تمرین بالا درست همانند محمول \متن‌لاتین{a2b/2} نوشته می‌شوند با این تفاوت که اینجا با سه لیست سر و کار داریم. اما تکنیک همان است. دو مسئله بعدی کمی جالبتر هستند. برای حل آنها می‌توانید از محمول \متن‌لاتین{member/2} استفاده کنید.

\begin{enumerate}
\فقره محمول \متن‌لاتین{mysubset/2} را طوری تعریف کنید که دو لیست از ثوابت به عنوان آرگومان دریافت کند و تعیین کند که آیا آرگومان اول زیر مجموعه‌ای از آرگومان دوم هست یا خیر.
\فقره محمول \متن‌لاتین{mysuperset/2} را طوری تعریف کنید که دو لیست به عنوان آرگومان دریافت کند و تعیین کند که آیا آرگومان اول سوپرست آرگومان دوم هست یا خیر.
\end{enumerate}