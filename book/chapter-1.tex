\chapter{حقایق، قواعد و پرسش}
\section{چند مثال ساده}
در پرولوگ تنها سه ساختار وجود دارد: حقایق\پانوشت{Facts}، قواعد\پانوشت{Rules} و پرسش‌ها\پانوشت{Queries}. مجموعه قواعد و حقایق با نام پایگاه دانش\پانوشت{\متن‌لاتین{Knowledge base}} یا پایگاه داده\پانوشت{\متن‌لاتین{Database}} شناخته می‌شوند. برنامه نویسی به زبان پرولوگ به معنی ساختن یک پایگاه داده است که در آن حقایق و قواعد مرتبط با مسئله مورد نظر ما درج شده‌اند. بدین ترتیب استفاده از این برنامه به صورت پرسش میسر است. یعنی ورودی برنامه پرسشی در مورد اطلاعات موجود در پایگاه داده است.

به چند پایگاه داده به زبان پرولوگ توجه کنید:

\subsection{\lr{Knowledge Base 1}}
پایگاه داده ۱ مجموعه ای از حقایق است. حقایق برای نمایش مواردی بکار می‌روند که بدون قید و شرط درست هستند. به عنوان مثال در اینجا گفته ایم که Mia و Judy و Yolanda زن هستند و Judy نوازنده گیتار است و مهمانی برقرار.

\begin{latin}
\begin{lstlisting}[title=KB1]
womain(mia).
woman(judy).
woman(yolanda).
playsAirGuitar(jody).
party.
\end{lstlisting}
\end{latin}

به این نکته توجه کنید که حرف اول تمام کلمات کوچک است. اینکار بی‌دلیل نیست. به زودی دلیل آن را خواهید دانست.

حال چطور می‌توانیم از این پایگاه داده استفاده کنیم؟ با پرسش سؤال در مورد اطلاعاتی که در KB1 وجود دارد. مثلاً می‌توانیم بپرسیم که آیا ‌Mia زن است؟

\begin{latin}
?- woman(mia).
\end{latin}

پرولوگ پاسخ خواهد داد:

\begin{latin}
yes
\end{latin}

واضح است که پرولوگ پاسخ صحیح داده است زیرا این حقیقت در پایگاه داده صریحاً درج شده است. توجه دارید که \متن‌لاتین{?-} علامت اعلان خط فرمان\پانوشت{prompt} در پرولوگ است و بسته به نسخه پرولوگی که استفاده می‌کنید می‌تواند متفاوت باشد. این علامت نشان می‌دهد که پرولوگ آماده دریافت دستور است. ما تنها پرسش مورد نظر خود (\متن‌لاتین{woman(mia)} به همراه نقطه انتهایی را درج می‌کنیم. نقطه انتهایی مهم است. بدون آن پرولوگ منتظر دریافت ادامه پرسش می‌ماند و کار خود را شروع نمی‌کند.

می‌توانیم سوالات دیگری از ‌‌پرولوگ بپرسیم. می‌خواهیم بدانیم آیا Jody گیتار می‌نوازد؟

\begin{latin}
\begin{lstlisting}
?- playsAirGuitar(jody).
yes
\end{lstlisting}
\end{latin}

پرولوگ پاسخ مثبت داد. اما اگر همین سوال را در مورد Mia بپرسیم پرولوگ چه پاسخی می‌دهد؟

\begin{latin}
\begin{lstlisting}
?- playsAirGuitar(mia).
no
\end{lstlisting}
\end{latin}

چرا پاسخ منفی بود؟ به این دلیل که حقیقتی مبنی بر نواختن گیتار توسط Mia در پایگاه داده وجود نداشت. بعلاوه KB1 پایگاه داده ساده‌ای است و قوانینی برای استنتاج نوازنده بودن در آن موجود نیست تا به پرولوگ برای یافتن پاسخ کمک کند. در ادامه در مورد قوانین بیشتر خواهید دانست.

حال سوال دیگری از پرولوگ می‌پرسیم:

\begin{latin}
\begin{lstlisting}
?- playsAirGuitar(vincent).
no
\end{lstlisting}
\end{latin}

پرولوگ پاسخ منفی می‌دهد. چرا؟ چون اطلاعاتی در مورد Vincent در پایگاه داده وجود ندارد. بنابراین طبق اطلاعات موجود ما نمی‌توانیم نتیجه بگیریم که Vincent نوازنده گیتار است.

به طور مشابه اگر از پرولوگ بپرسیم:

\begin{latin}
\begin{lstlisting}
?- married(Jody).
no
\end{lstlisting}
\end{latin}

دوباره پاسخ منفی است. زیرا این پرسش در مورد خصوصیتی (متاهل بودن) است که ما اطلاعی از آن نداریم پس نمی‌توانیم از اطلاعات موجود نتیجه بگیریم که Jody متاهل است. در بعضی از پیاده سازی های پرولوگ، پرسیدن این سوال باعث بروز خطا می‌شود و اعلام می‌شود که married تعریف نشده است.

به همین ترتیب می‌توانیم در مورد گزاره party هم سوال بپرسیم:

\begin{latin}
\begin{lstlisting}
?- party.
yes
\end{lstlisting}
\end{latin}

\subsection{\lr{Knowledge Base 2}}
با مثال دیگری کار را ادامه می‌دهیم.

\begin{latin}
\begin{lstlisting}[title=KB2]
happy(yolanda). 
listens2Music(mia). 
listens2Music(yolanda):-  happy(yolanda). 
playsAirGuitar(mia):-  listens2Music(mia). 
playsAirGuitar(yolanda):-  listens2Music(yolanda).
\end{lstlisting}
\end{latin}

در این پایگاه داده، دو حقیقت \متن‌لاتین{happy(yolanda)} و \متن‌لاتین{listens2Music(mia)} تعریف شده اند. سه مورد بعد قوانینی هستند که در این پایگاه تعریف شده‌است.

قانون یا قاعده اطلاعی است که مقدار درستی آن شرطی است و برحسب اطلاعات دیگر تعیین می‌شود. به عنوان مثال قاعده اول KB2 می‌گوید Yolanda موسیقی گوش می‌کند اگر شاد باشد. یا قاعده سوم می‌گوید Yolanda گیتار می‌نوازد اگر به موسیقی گوش می‌دهد. کافی است \متن‌لاتین{:-} را به صورت «اگر» یا «منتج می‌شود از» بخوانیم. قسمت سمت چپ \متن‌لاتین{:-}، سر یا head قاعده و قسمت سمت راست، بدنه یا body قاعده است. به صورت کلی یک قاعده می‌گوید اگر بنده درست باشد، سر قاعده نیز درست است.

بنابراین اگر پایگاه داده شامل قاعده‌ای به صورت \متن‌لاتین{head :- body} باشد و پرولوگ بر اساس اطلاعات دیگر موجود در پایگاه بداند که body درست است، می‌تواند نتیجه بگیرد که head هم درست است. به این نوع استنتاج «وضع مقدم\پانوشت{\متن‌لاتین{modus ponens}}» گفته می‌شود.

حال از پرولوگ می‌پرسیم:

\begin{latin}
\begin{lstlisting}
?- playsAirGuitar(mia).
\end{lstlisting}
\end{latin}

پاسخ مثبت است. زیرا هرچند پرولوگ نمی‌تواند حقیقت \متن‌لاتین{playsAirGuitar(mia)} را در KB2 بیابد، اما قاعده \متن‌لاتین{playsAirGuitar(mia):-  listens2Music(mia).} را می‌بیند. و علاوه بر این حقیقت \متن‌لاتین{listens2Music(mia)} نیز در KB2 وجود دارد. بنابراین با استفاده از وضع مقدم نتیجه می‌گیرد که \متن‌لاتین{playsAirGuitar(mia)} درست است.

با یک سوال دیگر می‌توان نشان داد که پرولوگ می‌تواند به صورت زنجیره‌ای از وضع مقدم استفاده کند:

\begin{latin}
\begin{lstlisting}
?- playsAirGuitar(yolanda).
yes
\end{lstlisting}
\end{latin}

پاسخ مثبت است زیرا پرولوگ با استفاده از حقیقت \متن‌لاتین{happy(yolanda)} و قاعده \\
 \متن‌لاتین{listens2Music(yolanda):-  happy(yolanda)} \\
نتیجه می‌گیرد که \متن‌لاتین{listens2Music(yolanda)}. هرچند این حقیقت به صورت صریح در KB2 وجود ندارد اما پرولوگ از آن استفاده می‌کند و با استفاده از قاعده \متن‌لاتین{playsAirGuitar(yolanda):-  listens2Music(yolanda)}  نتیجه می‌گیرد که باید پاسخ مثبت بدهد. پس هر حقیقتی که با استفاده از وضع مقدم نتیجه شود می‌تواند به صورت ورودی برای قواعد دیگر مورد استفاده قرار بگیرد. به این ترتیب با استفاده زنجیری از وضع مقدم پرولوگ قادر است اطلاعاتی که بطور منطقی از قواعد و حقایق موجود قابل نتیجه گیری است، بدست آورد.

به قواعد و حقایق موجود در یک پایگاه داده، clause گفته می‌شود. بنابراین KB2 شامل پنج clause است، سه قاعده و دو حقیقت. همچنین این پایگاه از سه مسند یا predicate تشکیل شده است. این سه مسند عبارت اند از:

\begin{latin}
listens2Music \\
happy \\
playsAirGuitar \\
\end{latin}

مسند happy با استفاده از یک clause (یک حقیقت) تعریف شده است. مسند listens2Music و playsAirGuitar هر کدام توسط دو clause (در مورد اول دو قاعده و در مورد دوم یک قاعده و یک حقیقت) تعریف شده اند. این نوع نگاه به برنامه های پرولوگ مفید است. در واقع clause هایی که در برنامه می‌نویسیم در واقع تلاشی برای معنی دادن به مسندها و برقراری ارتباط بین آن‌هاست.

نکته آخر اینکه می‌توانیم به حقایق به صورت قواعدی نگاه کنیم که بدنه آنها تهی است. بنابراین به انتفاع مقدم، حقایق درست هستند.

\subsection{\lr{Knowledge Base 3}}
پایگاه داده بعدی شامل پنج clause است، دو حقیقت و یک قاعده:

\begin{latin}
\begin{lstlisting}[title=KB3]
happy(vincent).
listens2Music(butch).
playsAirGuitar(vincent):-
  listens2Music(vincent),
  happy(vincent).
playsAirGuitar(butch):-
  happy(butch).
playsAirGuitar(butch):-
  listens2Music(butch).
\end{lstlisting}
\end{latin}

در پایگاه KB3 سه predicate هم نام KB2 تعریف شده‌اند (happy ،listen2Music و playsAirGuitar) تنها تفاوت در تعریف آنهاست و این تعاریف دارای نکاتی است که در اینجا به آنها می‌پردازیم. قاعده

\begin{latin}
\begin{lstlisting}
playsAirGuitar(vincent):-
  listens2Music(vincent),
  happy(vincent).
\end{lstlisting}
\end{latin}

در بدنه خود دو بخش یا goal دارد که با یک comma از یکدیگر جدا شده‌اند. در واقع این comma در زبان پرولوگ نشان دهنده عطف منطقی است. بنابراین این قاعده به معنی این است که: «Vincent گیتار می‌نوازد اگر او به موسیقی گوش دهد و شاد باشد».

با این وصف، اگر از پرولوگ بپرسیم:

\begin{latin}
\begin{lstlisting}
?- playsAirGuitar(vincent).
\end{lstlisting}
\end{latin}

پاسخ منفی خواهد بود. زیرا اگرچه KB3 شامل \متن‌لاتین{happy(vincent)} است، اما اطلاعی در مورد \متن‌لاتین{listens2Music(vincent)} چه مستقیم و چه غیر مستقیم به ما نمی‌دهد. به همین دلیل تنها یکی از شروط قاعده بالا برقرار است و پرولوگ به درستی پاسخ منفی می‌دهد.

نکته بعدی مربوط به دو قاعده با head یکسان است که در KB3 تعریف شده‌اند:

\begin{latin}
\begin{lstlisting}
playsAirGuitar(butch):-
  happy(butch).
playsAirGuitar(butch):-
  listens2Music(butch).
\end{lstlisting}
\end{latin}

می‌توان این دو قاعده را اینطور معنا کرد: «Butch گیتار می‌نوازد اگر خوشحال باشد یا به موسیقی گوش‌ دهد». پس برای نشان دادن یا منطقی در پرولوگ قواعدی با head یکسان تعریف می‌کنیم.

می‌توانید حدس بزنید که اگر از پرولوگ بپرسیم:

\begin{latin}
\begin{lstlisting}
?- playsAirGuitar(butch).
\end{lstlisting}
\end{latin}

پاسخ مثبت است. زیرا اگرچه اولین قاعده به کار نمی‌آید (\متن‌لاتین{happy(butch)} در پایگاه داده نیست) اما به کمک دومین قاعده و استفاده از وضع مقدم پرولوگ پاسخ صحیح مثبت را چاپ می‌کند.

راه دیگری برای تعریف یا منطقی در پرولوگ وجود دارد. قاعده زیر درست همانند دو قاعده بالا هستند.

\begin{latin}
\begin{lstlisting}
playsAirGuitar(butch):-
  happy(butch);
  listens2Music(butch).
\end{lstlisting}
\end{latin}

به وجود semicolon دقت کنید. semicolon در پرولوگ به معنی یا منطقی است. ممکن است این سوال پیش بیاید که آیا بهتر است از چند قاعده برای تعریف یا استفاده کنیم یا از یک قاعده. استفاده از دو قاعده باعث خوانایی بیشتر برنامه می‌شود. اما استفاده از یک قاعده از لحاظ اجرایی کاراتر است زیرا پرولوگ با یک قاعده سر و کار دارد.

دانستیم که «\متن‌سیاه{\متن‌لاتین{:-}}» نشان‌دهنده نتیجه گیری و «\متن‌سیاه{\متن‌لاتین{,}}» نماد عطف منطقی و «\متن‌سیاه{\متن‌لاتین{;}}» نماد یا منطقی است.(اگر در مورد عملگر نفی منطقی بپرسید باید گفت اینکار پیچیده‌تر است و در فصول بعد بدان خواهیم پرداخت.) بعلاوه کاربرد قاعده منطقی استنتاج وضع مقدم را هم بارها از ابتدای این فصل دیده‌ایم. حالا درک می‌کنیم که چرا پرولوگ مخفف \متن‌لاتین{Programming in Logic} است.

\subsection{\lr{Knowledge Base 4}}
چهارمین پایگاه

\begin{latin}
\begin{lstlisting}[title=KB4]
woman(mia). 
woman(jody). 
woman(yolanda). 
    
loves(vincent,mia). 
loves(marsellus,mia). 
loves(pumpkin,honey_bunny). 
loves(honey_bunny,pumpkin).
\end{lstlisting}
\end{latin}

هرچند در اینجا رابطه‌هایی را مشاهده می‌کنیم که دو آرگومان دارند اما هدف اصلی از این پایگاه داده چیز دیگری است. در واقع می‌خواهیم کمی بیشتر با پرسش از پرولوگ آشنا شویم و برای اولین بار از متغیرها استفاده کنیم:

\begin{latin}
\begin{lstlisting}
?- woman(X).
\end{lstlisting}
\end{latin}

همانطور که حدس می‌زنید X در اینجا یک متغیر است. درحقیقت هر کلمه‌ای که با حروف بزرگ آغاز شود از دید پرولوگ یک متغیر است. به همین دلیل تا اینجا در تمام برنامه‌هایی که نوشتیم نام‌گذاری‌‌ها با حروف کوچک انجام شده است. این مثال از پرولوگ می‌پرسد: کدام اشخاصی که می‌شناسی زن هستند؟

پرولوگ برای پاسخ به این سوال در پایگاه KB4 از بالا به پایین شروع به جستجو می‌کند تا بتواند عبارت \متن‌لاتین{woman(X)} را با اطلاعات موجود ‌پاسخ دهد. اولین عبارتی که در KB4 وجود دارد حقیقت \متن‌لاتین{womain(mia)} است. پرولوگ X را با mia متحد یا unify می‌کند و می‌تواند عبارت مورد جستجو را با این حقیقت کاملاً  تطبیق دهد. (اصطلاحات دیگری نیز برای اینکار مورد استفاده قرار می‌گیرد از جمله اینکه پرولوگ X را به mia instantiate می‌کند یا X را به mia bind می‌کند.) پاسخ پرولوگ اینچنین خواهد بود:

\begin{latin}
\begin{lstlisting}
X = mia
\end{lstlisting}
\end{latin}

این پاسخ نه تنها می‌گوید حداقل یک زن در پایگاه داده وجود دارد بلکه نام او را نیز گزارش می‌کند. به عبارت دیگر پرولوگ علاوه بر پاسخ yes، \متن‌لاتین{variable binding} مورد استفاده که منجر به پاسخ yes می‌شود را هم گزارش می‌کند.

اما این پایان ماجرا نیست! نکته اینجاست که خاصیت متغیرها این است که می‌توانند به بیش از یک چیز bind یا unify شوند. در KB4 چند خانم وجود دارند. پرولوگ می‌تواند باقی پاسخ ها یا binding ها را نیز به ما نشان دهد. با تایپ یک \متن‌لاتین{;} می‌توانیم این پاسخ‌ها را ببینیم:

\begin{latin}
\begin{lstlisting}
X = mia ;
X = jody
\end{lstlisting}
\end{latin}

به یاد دارید که \متن‌لاتین{;} به معنی یا است. به این ترتیب به پرولوگ می‌گویم آیا جایگزین دیگری هم وجود دارد؟ پرولوگ از جایی که پاسخ قبل را یافته بود ادامه می‌دهد تا پاسخ دیگری بیابد. به خط دوم KB4 می‌رسد و X را با jody متحد می‌کند تا ببیند آیا می‌تواند پاسخی بیابد. در این حالت عبارت \متن‌لاتین{womain(jody)} ساخته می‌شود که با حقیقت موجود در خط دوم کاملا منطبق است. پس پرولوگ توانسته پاسخ دیگری بیابد و jody را به عنوان پاسخ بعدی اعلام می‌کند. بار دیگر هم می‌توانیم \متن‌لاتین{;} را تایپ کنیم تا پاسخ بعدی را ببینیم:

\begin{latin}
\begin{lstlisting}
X = mia ;
X = jody ;
X = yolanda
\end{lstlisting}
\end{latin}

اگر بار دیگر \متن‌لاتین{;} را تایپ کنیم پرولوگ پاسخ No می‌دهد. یعنی unification دیگری وجود ندارد. چون پرولوگ می‌داند که هیچ حقیقت دیگری با woman شروع نشده است و روابط بعدی هم به هیچ عنوان نمی‌توانند با پرسش موردنظر منطبق شوند.

بیایید یک پرسش پیچیده‌تر را امتحان کنیم:

\begin{latin}
\begin{lstlisting}
?- loves(marsellus,X), woman(X).
\end{lstlisting}
\end{latin}

اگر به یاد داشته باشید \متن‌لاتین{,} به معنی عطف است. پس این پرسش می‌گوید که آیا هیچ X ای وجود دارد که Marsellus او را دوست داشته باشد و X زن باشد؟ با نگاهی به پایگاه KB4 می‌بینیم که پاسخ باید مثبت باشد چون Mia یک زن است و Marsellus او را دوست دارد. پرولوگ این پاسخ را می‌یابد و آن را اعلام می‌کند. اینکه چطور پرولوگ می‌تواند این کار را انجام دهد به فصل‌های بعدی موکول می‌شود.

پروسه متحد کردن متغیرها با اطلاعات موجود در پایگاه داده قلب پرولوگ است. ایده‌های جالب و گوناگونی در پرولوگ وجود دارد اما در انتها همه آنها به unification ختم می‌شوند.\\

\subsection{\lr{Knowledge Base 5}}
تا اینجا متغیرها را معرفی کرده و از آنها در پرسش‌ها استفاده کردیم. می‌توان از متغیرها در پایگاه داده نیز استفاده کرد:

\begin{latin}
\begin{lstlisting}[title=KB5]
loves(vincent,mia). 
loves(marsellus,mia). 
loves(pumpkin,honey_bunny). 
loves(honey_bunny,pumpkin). 
    
jealous(X,Y):-  loves(X,Z),  loves(Y,Z).
\end{lstlisting}
\end{latin}

KB5 شامل چهار حقیقت و یک قانون است. (توجه کنید که خط خالی بین حقایق و قانون معرفی شده معنی خاصی ندارد و فقط جهت خوانایی است.) البته این قانون جالب‌ترین قانونی است که تا به حال تعریف کرده‌ایم زیرا سه متغیر در آن بکار رفته‌اند. ( دقت کرده‌اید که متغیرها با حرف بزرگ آغاز می‌شوند.) 

قانون بکار رفته مفهوم حسادت را بیان می‌کند. این قانون می‌گوید که شخص X به شخص Y حسادت می‌کند اگر شخص Z وجود داشته باشد که هم X و هم Y او را دوست داشته باشند. (هرچند در دنیای واقعی هیچ چیز آنقدر ساده نیست!) نکته اینجاست که این قانون یک مفهوم را در دنیای کوچک پایگاه KB5 بدون در نظر گرفتن اسم اشخاص تعریف می‌کند.

اگر بخواهیم بدانیم آیا شخصی وجود دارد که Marsellus به او حسادت کند از پرولوگ می‌پرسیم:

\begin{latin}
\begin{lstlisting}
?- jealous(marsellus,W).
\end{lstlisting}
\end{latin}

\متن‌لاتین{Vincent} این شخص است! بنابراین پرولوگ پاسخ می‌دهد:

\begin{latin}
\begin{lstlisting}
W = vincent
\end{lstlisting}
\end{latin}

یک پرسش از شما. آیا شخص دیگری هم می‌توانست پاسخ این سوال باشد؟ چطور باید از پرولوگ بخواهیم پاسخ پرسش ما را بدهد؟

\section{\lr{Prolog Syntax}}
حال که با چند مثال ساده از پرولوگ آشنا شدیم وقت آن است که برگردیم و با دقت بیشتری زبان پرولوگ را مورد بررسی قرار دهیم.

حقایق و قواعد و پرسش‌ها از چه اجزایی ساخته شده‌اند؟ term ها پاسخ پرسش ما هستند. چهار نوع term در پرولوگ وجود دارد. اتم‌ها، اعداد، متغیرها و ترم‌های مرکب\پانوشت{Complex Terms} یا ساخت‌ها\پانوشت{Structures}. اتم‌ها و اعداد با یکدیگر ثوابت یا constant ها را تشکیل می‌دهند که در ادامه توضیح می‌دهیم. این ثوابت به همراه متغیرها ترم‌های ساده پرولوگ را تشکیل می‌دهند.

بیایید دقیقتر نگاه کنیم. اول در ارتباط با کاراکترهای ساده (یا symbol ها). حروف بزرگ A تا Z، حروف کوچک a تا z و اعداد 0 تا 9 به همراه کاراکترهای \_، +، -، *، /، >، <، =، :، .، \&، ~ و برخی کاراکترهای دیگر از جمله کاراکتر فاصله، کاراکترهای ساده را تشکیل می‌دهند.

\subsection{اتم‌ها}

اتم ها یا
\begin{enumerate}
\item
مجموعه‌ای از کاراکترها شامل حروف کوچک و بزرگ و اعداد و \_ هستند که با یک حرف کوچک آغاز شوند. مثلاً  \متن‌لاتین{butch}، \متن‌لاتین{big\_kahuna\_burger} یا \متن‌لاتین{playsAirGuitar}.
\item
مجموعه دلخواهی از کاراکترها بین دو single quote. برای مثال \متن‌لاتین{'Vincent'} یا \متن‌لاتین{'The  Gimp'}. به مجموعه کاراکترها بین دو علامت اعلان، atom name گفته می‌شود. دقت کنید که می‌توانیم از کاراکتر فاصله در این حالت استفاده کنیم و در واقع این نکته دلیل اصلی استفاده از atom name‌هاست.
\item 
رشته‌ای از کاراکترهای خاص. برای مثال می‌توان به \متن‌لاتین{@=} و \متن‌لاتین{===>} و \متن‌لاتین{;} اشاره کرد. همانطور که مشخص است بعضی از این اتم‌ها دارای معنی از پیش تعریف شده هستند مثل \متن‌لاتین{;}.
\end{enumerate}

\subsection{اعداد}

هرچند پرولوگ از اعداد حقیقی پشتیبانی می‌کند و می‌توان آنها را در نمایش داد اما این اعداد در پرولوگ اهمیت زیادی ندارند. در مقابل اعداد صحیح ( یعنی مجموعه اعداد \متن‌لاتین{...,-2,-1,0,1,2,...}) کاربردهای مختلفی دارند از جمله اندیس گذاری لیست ها که بعداً به آنها خواهیم پرداخت.

\subsection{متغیرها}

متغیرها رشته‌هایی هستند شامل حروف بزرگ، حروف کوچک، اعداد و \_ که با یک حرف بزرگ یا \_ آغاز شود. به عنوان مثال X‌، Y و \متن‌لاتین{\_tag} و Tail همگی نشان دهنده متغیرها هستند.

متغیر \_ یک متغیر خاص است که در فصل‌های بعدی بدان خواهیم پرداخت.

\subsection{ترم‌های مرکب}

ترم‌های مرکب یا ساخت‌ها از ترم‌های ساده تشکیل شده‌اند. بطور دقیقتر هر ترم مرکب از یک عملگر یا functor به همراه تعدادی آرگومان تشکیل شده است. آرگومان‌ها با کاما از یکدگیر جدا شده و بین دو پرانتز قرار داده می‌شوند. ابتدا اسم عملگر و سپس آرگومان‌های آن قرار می‌گیرند. بین اسم عملگر و پرانتز شروع آرگومان‌ها نباید هیچ فاصله‌ای قرار داده شود. functor باید یک اتم باشد. یعنی متغیرها نمی‌توانند functorباشند. در مقابل آرگومان‌ها می‌توانند هر نوع ترمی باشند.

قبلاً در حین بررسی پایگاه‌های KB1 تا KB5 بسیاری از ترم‌های مرکب را دیده‌ایم. برای مثال \متن‌لاتین{playsAirGuitar(jody)} یک ترم مرکب است: functor آن playsAirGuitar  است و تک آرگومان آن jody است. مثال دیگر می‌تواند \متن‌لاتین{ loves(vincent,mia)} باشد که در آن loves عملگر و vincent و mia دو آرگومان آن هستند. \متن‌لاتین{jealous(marsellus,W)} نیز یک ترم مرکب است که یک متغیر در آرگومان‌های آن قرار دارد.

تعریف بالا اجازه می‌دهد که ترم‌های پیچیده‌تری بسازیم. در واقع می‌توانیم ترم‌های مرکب را داخل یکدیگر جای دهیم\پانوشت{به اینکار nesting گفته می‌شود}. برای مثال \متن‌لاتین{hide(X,father(father(father(butch))))} یک ترم مرکب است. functor آن hide و دو آرگومان آن یکی متغیر X و دیگری ترم مرکب \\\متن‌لاتین{father(father(father(butch)))} است. به همین ترتیب ترم‌های مرکب داخل هم ترکیب شده‌اند تا جایی که به \متن‌لاتین{father(butch)} می‌رسیم که آرگومان آن ثابت butch هست.

به تعداد آرگومان‌های یک ترم مرکب arity گفته می‌شود. مثلاً \متن‌لاتین{womain(mia)} یک ترم پیچیده با arity یک است و \متن‌لاتین{loves(vincent,mia)} دارای arity دو است.

اگر چند ترم مرکب با functor یکسان ولی با تعداد آرگومان متفاوت تعریف کنیم مشکلی پیش نمی‌آید. در ادامه خواهیم دید که این قابلیت مهم و کاربردی در پرولوگ است.

هنگامی که در مورد یک گزاره صحبت می‌کنیم (مثلاً برای مستندسازی برنامه) معمول است که arity آن را بعد از یک / مشخص کنیم. مثلاً در KB2 گزاره‌های زیر را داریم:

\begin{latin}
\begin{lstlisting}
listens2Music 
happy 
playsAirGuitar
\end{lstlisting}
\end{latin}

که باید بگوییم گزاره های زیر را تعریف کرده‌ایم:

\begin{latin}
\begin{lstlisting}
listens2Music/1 
happy/1
playsAirGuitar/1
\end{lstlisting}
\end{latin}

\clearpage

\section{تمرین‌ها}
\begin{exercise}
کدامیک از رشته‌ کاراکترهای زیر اتم، کدام‌ متغیر و کدام نه اتم و نه متغیر هستند؟\\
\begin{latin}
\begin{enumerate}
\item vINCENT
\item Footmassage
\item variable23
\item Variable2000
\item big\_kahuna\_burger
\item 'big  kahuna  burger'
\item big  kahuna  burger
\item 'Jules'
\item \_Jules
\item '\_Jules'
\end{enumerate}
\end{latin}
\end{exercise}

\begin{exercise}
کدامیک از رشته کاراکترهای زیر اتم، متغیر، ترم مرکب اند و کدامیک ترم نیستند؟\\
\begin{latin}
\begin{enumerate}
\item loves(Vincent,mia)
\item 'loves(Vincent,mia)'
\item boxer(Butch)
\item and(big(burger),kahuna(burger))
\item and(big(X),kahuna(X))
\item \_and(big(X),kahuna(X))
\item (Butch  kills  Vincent)
\item kills(Butch  Vincent)
\item kills(Butch,Vincent
\end{enumerate}
\end{latin}
\end{exercise}

\begin{exercise}
در پایگاه داده زیر چند حقیقت، قاعده، clause و گزاره وجود دارند؟ قسمت head و goal هر قاعده را مشخص کنید.
\begin{latin}
\begin{lstlisting}
woman(vincent). 
woman(mia). 
man(jules). 
person(X) :- man(X); woman(X). 
loves(X,Y) :- father(X,Y). 
father(Y,Z) :- man(Y), son(Z,Y). 
father(Y,Z) :- man(Y), daughter(Z,Y).
\end{lstlisting}
\end{latin}
\end{exercise}

\begin{exercise}
گزاره های زیر را به زبان پرولوگ بنویسید.
\begin{latin}
\begin{enumerate}
\item Butch is a killer.
\item Mia and Marsellus are married.
\item Zed is dead.
\item Mia loves everyone who is a good signer.
\item Jules eats anything that is nutritious or tasty.
\end{enumerate}
\end{latin}
\end{exercise}

\begin{exercise}
فرض کنید که پایگاه داده زیر را در پرولوگ تعریف کرده‌ایم
\begin{latin}
\begin{lstlisting}
wizard(ron). 
hasWand(harry). 
quidditchPlayer(harry). 
wizard(X):-  hasBroom(X),  hasWand(X). 
hasBroom(X):-  quidditchPlayer(X).
\end{lstlisting}
\end{latin}
\noindent پاسخ پرولوگ به پرسش‌های زیر چیست؟
\begin{latin}
\begin{enumerate}
\item wizard(ron).
\item witch(ron).
\item wizard(hermione).
\item witch(hermione).
\item wizard(harry).
\item wizard(Y).
\item witch(Y).
\end{enumerate}
\end{latin}
\end{exercise}

\clearpage

\section{تمرین عملی}
هدف از اولین تمرین عملی، آشنایی با نحوه اجرای برنامه‌های پرولوگ است. برای اجرای تمرین عملی باید کامپایلر و برنامه پرولوگ را روی سیستم خود نصب کنید. پیاده‌سازی های متفاوتی از پرولوگ وجود دارد. در این کتابچه ما از پیاده‌سازی \متن‌لاتین{SWI-Prolog} استفاده می‌کنیم. برای نصب SWI-Prolog روی سیستم کافی است به سایت swi-prolog.org\پانوشت{http://www.swi-prolog.org/download/stable} مراجعه کنید و فایل نصاب متناسب با سیستم عامل خود را دریافت کرده و آن را اجرا نمایید.

برای شروع کار پایگاه داده KB2 را در فایلی با نام \متن‌لاتین{kb2.pl} قرار دهید. سپس در ترمینال به مسیری که فایل خود را ذخیره کرده‌اید رفته و دستور swipl را اجرا کنید. خواهید دید که پرولوگ منتظر اجرای فرامین شما خواهد بود.

تا اینجای کار پرولوگ هیچ چیز در مورد KB2 نمی‌داند. برای اطمینان دستور \متن‌لاتین{.listing} را تایپ کرده و دکمه Enter را فشار دهید.

\begin{latin}
\begin{lstlisting}
?- listing.
true.
\end{lstlisting}
\end{latin}

دستور listing یک دستور از پیش تعریف شده در پرولوگ است. این دستور به پرولوگ می‌گوید محتوای پایگاه داده جاری را چاپ کند. از آنجایی که هنوز پایگاه داده‌ای در پرولوگ بارگزاری نکرده‌ایم تنها پاسخ \متن‌لاتین{true.} را خواهیم دید. یعنی پرولوگ چیزی برای نمایش ندارد. (البته ممکن است اطلاعاتی راجع به محیط اجرا و متغیرهای داخلی پرولوگ برگردانده شود.)

بیایید KB2 را به پرولوگ بشناسانیم! دستور زیر پایگاه داده را در پرولوگ بارگزاری خواهد کرد:

\begin{latin}
\begin{lstlisting}
?- [kb2].
% kb2 compiled 0.00 sec, 6 clauses
true.
\end{lstlisting}
\end{latin}

اگر دستور بالا پاسخی غیر از \متن‌لاتین{true.} داد مشکلی به وجود آمده است. در این حالت یا اشتباه تایپی در پایگاه داده وجود دارد یا فایل \متن‌لاتین{kb2.pl} در مسیر کنونی وجود ندارد. در این حالت باید از پرولوگ خارج شوید، مسیر را به جایی که فایل \متن‌لاتین{kb2.pl} را ذخیره کرده‌اید تغییر داده و دوباره swipl را اجرا کنید. برای خروج از پرولوگ از دستور \متن‌لاتین{halt.} زیر استفاده کنید. راه دیگری نیز وجود دارد. می‌توانید به جای خروج از پرولوگ، آدرس دقیق فایل پایگاه داده را به پرولوگ دهید:

\begin{latin}
\begin{lstlisting}
?- ['c:/Documents and Settings/Morteza/prolog/snippets/kb2.pl'].
% kb2 compiled 0.00 sec, 6 clauses
true.
\end{lstlisting}
\end{latin}

برای اطمینان از حصول نتیجه بار دیگر دستور \متن‌لاتین{listing.} را اجرا کنید و ببینید پرولوگ چه محتوایی را چاپ می‌کند.

دستور \متن‌لاتین{listing} اشکال دیگری نیز دارد. مثلاً می‌توانید ببینید که چه گزاره هایی شامل \متن‌لاتین{playsAirGuitar} در پایگاه داده وجود دارند:

\begin{latin}
\begin{lstlisting}
?- listing(playsAirGuitar).

playsAirGuitar(mia):-
  listens2Music(mia).
playsAirGuitar(yolanda):-
  listens2Music(yolanda).

true.
\end{lstlisting}
\end{latin}

حالا آماده‌اید تا از پرولوگ در مورد این پایگاه سوال بپرسید. این کار را با چند پایگاه داده معرفی شده در این فصل تکرار کنید و سعی کنید پرسش‌هایی که در طول فصل به آنها پرداختیم را امتحان کنید.